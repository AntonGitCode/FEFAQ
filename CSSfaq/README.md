[типы input](#inputs)  
[z-index контекст наложения](https://github.com/AntonGitCode/FEFAQ/blob/master/CSS/4.md)  
[бэм](#bemwtf)

- [Что такое CSS? И для чего он используется?](#wtfcss)
- [Что такое CSS-правило?](#cssrule)
- [Варианты добавление CSS стилей на страницу?](#cssstyles)
- [Типы позиционирования в CSS?](#csspos)
- [Блочная модель CSS?](#cssblockmodel)
- [Что такое селектор? И какие селекторы существуют?](#selectors)
- [Что такое специфичность селектора? Как считать вес селектора?](#selspec)
- [Разница между Reset.css и Normalize.css?](https://youtu.be/G7hLwudGWL4?t=445)
- [Разница между `margin` и `padding`?](https://youtu.be/1eIRTdgzHtw?t=116)
- [Разница между `display: none` и `visibility: hidden`?](#displayvshidden)
- [Разница между блочным и строчным (инлайновым) элементами?](#blockvsinline)
- [Разница между классом и идентификатором в CSS?](#classvsid)
- [Что такое CSS спрайт? И для чего он используется?](https://youtu.be/CjdCxxqObaM?t=330)
- [Что такое вендорные префиксы? И для чего они используются?](https://youtu.be/rlWgI7AvV18?t=234)
- [Что такое псевдоэлементы? И для чего они используются?](https://youtu.be/rlWgI7AvV18?t=355)
- [Что такое схлопывание границ (margin collapsing)?](#margincoll)
- [Что такое CSS препроцессор?](#csspreproc)
- [Что такое `z-index`? Как формируется контекст наложения?](https://youtu.be/GZUy2i6QN7o?t=102)
- [Порядок наложения элементов в CSS (Stacking Order)?](https://youtu.be/GZUy2i6QN7o?t=204)
- [Как с помощью CSS определить, поддерживается ли свойство в браузере?](#cssbro)
- [Как поддерживать страницы в браузерах с ограниченными функциями?](https://youtu.be/70VnuTXi4Wk?t=75)
- [Как исправлять специфичные проблемы со стилями для разных браузеров?](https://youtu.be/70VnuTXi4Wk?t=122)
- [Глобальные ключевые слова в CSS?](#globalcss)
- [Что такое CSS-атрибут (`attr`)?](#attr)
- [Что такое перечисление селекторов?](#selectors)
- [ключевое слово `currentColor` в CSS?](#curcol)
- [Какие псевдоклассы были добавлены в CSS3?](#csss)
- [Какие фильтры есть в CSS?](#cssfilters)
- [Для чего используется псевдокласс `:invalid`?](#invalid)
- [Расскажите про свойство `display` в CSS?](#display)
- [В каком случае лучше использовать `translate()` вместо абсолютного позиционирования?](#translate)
- [Что такое плавающие элементы (floats)? Как они работают?](https://youtu.be/xIGp2FCxqj0?t=610)
- [Расскажите о свойстве `text-rendering`?](#txtrendering)
- [Расскажите о свойстве `text-decoration-skip-ink`?](#skipink)
- [Расскажите о свойстве `pointer-events`?](#pointer)
- [Расскажите о свойстве `outline`?](#outln)
- [Расскажите о свойстве `scrollbar-gutter`?](#gutter)
- [Почему не стоит использовать краткую запись свойств CSS?](#cssshot)
- [Назовите псевдоэлементы для подсветки текста?](#pseudolight)
- [Способы задания цвета в CSS?](#colorcss)
- [Какие CSS-свойства используются для создания анимаций и плавных переходов?](#transition)
- [Принципы и подходы для обеспечения масштабируемости и поддерживаемости CSS-кода?](#cssscale)
- [Плюсы и минусы методологии БЭМ?](#bemwtf)
- [Какие CSS-препроцессоры вы знаете? Преимущества их использования?](#sass)

<a name="inputs"></a>
<h2>типы input</h2>  

1. `<input type="text">`: Это наиболее распространенное поле ввода для текстовых данных. Пользователь может ввести однострочный текст.

2. `<input type="password">`: Этот тип используется для ввода пароля. Текст, введенный пользователем, будет скрыт символами "*".

3. `<input type="email">`: Этот тип используется для ввода email-адреса. Браузер может проверить, содержит ли введенное значение символ "@".

4. `<input type="number">`: Этот тип используется для ввода числовых значений. Браузер может предоставить кнопки для увеличения и уменьшения значения или ограничить ввод нечисловыми символами.

5. `<input type="checkbox">`: Этот тип используется для ввода флажка (checkbox). Пользователь может выбрать или снять флажок с помощью клика.

6. `<input type="radio">`: Этот тип используется для ввода радио-кнопки (radio button). Пользователь может выбрать только одну опцию из предложенного списка.

7. `<input type="file">`: Этот тип позволяет пользователю выбрать файл с компьютера для загрузки на сервер.

Это лишь некоторые виды `<input>`, но в HTML есть и другие типы, такие как `date`, `time`, `color`, `range` и другие. 

<a name="wtfcss"></a>
<h2>Что такое CSS?</h2>
  
CSS (Cascading Style Sheets) - это язык стилей, используемый для описания внешнего вида и форматирования документа, написанного с использованием языка разметки, такого как HTML или XML. Основная цель CSS - разделить контент от его представления, что позволяет легко изменять стиль и макет веб-страницы без изменения ее содержимого.  
  
С помощью CSS можно задавать различные свойства элементов веб-страницы, такие как цвет фона, шрифт, размер, отступы, выравнивание, рамки и другие стилизационные аспекты. Он также позволяет создавать анимации, применять трансформации и определять адаптивное поведение элементов на разных устройствах и размерах экранов.  
  
CSS используется для придания визуального оформления веб-страницам, делая их более привлекательными и удобочитаемыми.  

<a name="cssrule"></a>
<h2>Что такое CSS-правило?</h2>  
  
  CSS правила состоят из селектора и объявления стилей.
  это блок кода, который определяет, как будет выглядеть элемент на веб-странице. 
  
<a name="cssstyles"></a>
<h2>Варианты добавление CSS стилей на страницу?</h2>  

  1. Встроенные стили. с помощью style в head, или внутри тега  ``` <h1 style="color: blue; font-size: 24px;">Привет, мир!</h1>```  
  2. Внешние файлы стилей. в html: ```<link rel="stylesheet" href="styles.css">```  

```html
<!DOCTYPE html>
<html>
<head>
    <title>Моя страница</title>
    <style>
        h1 {
            color: blue;
            font-size: 24px;
        }
        p {
            color: green;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <h1>Привет, мир!</h1>
    <p>Это моя страница.</p>
</body>
</html>
```
  
<a name="csspos"></a>
<h2>Типы позицинирования</h2>

1. **Static** (Статическое позиционирование): это значение позиционирования по умолчанию для всех элементов. Элементы с таким позиционированием выводятся в порядке, заданном в коде их разметки, и не затрагивают позиционирование других элементов.

2. **Relative** (Относительное позиционирование): с помощью этого типа позиционирования элементы можно сдвигать относительно их исходного местоположения. Они все еще занимают свое место в потоке документа, но их позиция может быть изменена с помощью сдвига относительно себя или других элементов.
 
3. **Absolute** (Абсолютное позиционирование): элементы с абсолютным позиционированием полностью удалены из нормального потока документа и помещаются в определенное место на странице. Они позиционируются относительно ближайшего элемента с позиционированием, отличным от статического (если такого элемента нет, то относительно самого окна просмотра). При использовании абсолютного позиционирования элементы выходят из нормального потока и не занимают пространство для других элементов.

4. **Fixed** (Фиксированное позиционирование): элементы с фиксированным позиционированием фиксируются относительно окна просмотра, то есть они останутся на месте, даже при прокрутке страницы. Они также выходят из нормального потока.

5. **Sticky** (Прилипающее позиционирование): элементы с прилипающим позиционированием начинают залипать (приклеиваться) к определенной позиции на странице при достижении этой позиции при прокрутке. Они остаются в потоке документа и занимают свое место, пока не достигнут нужной позиции.

<a name="cssblockmodel"></a>
<h2>Блочная модель</h2>  
  
Блочная модель CSS состоит из следующих компонентов:  
  
1. **Content** (Содержимое): это часть элемента, которая содержит его реальное содержимое, такое как текст, изображения, видео и т. д. Ширина и высота содержимого задаются с помощью свойств width и height.  
  
2. **Padding** (Внутренние отступы): это пространство между содержимым элемента и его границей. Отступы определяются с помощью свойств padding-top, padding-right, padding-bottom и padding-left.  
  
3. **Border** (Границы): это линия, окружающая содержимое элемента и отделяющая его от других элементов. Границы могут быть заданы с помощью свойств border-width, border-style и border-color.  
  
4. **Margin** (Внешние отступы): это пространство вокруг элемента, которое разделяет его соседние элементы. Отступы определяются с помощью свойств margin-top, margin-right, margin-bottom и margin-left.  

<a name="selectors"></a>  
<h2>Что такое селектор? И какие селекторы существуют?</h2>  

  **Селектор** - **это часть CSS правила, которая указывает, на какие элементы веб-страницы должны быть применены определенные стили или свойства.**

Существуют различные **типы селекторов** в CSS:

- Универсальный селектор *
-  по **тегу** (элементу)
-  по идентификатору (id) #id
-  по классу (class) .className
- по атрибуту [attr]
- Группа селекторов  , ,

<img src="https://github.com/AntonGitCode/FEFAQ/assets/117078390/e16b25fe-1d69-4c18-b60a-0d132d7f6c8d" width=450>  

<a name="selspec"></a>
<h2>Специфичность селекторов</h2>

**Специфичность** — _это алгоритм, благодаря которому браузер определяет, какие именно стили из всего набора применить к элементу._  
 **```EN```** specificity 
   
В следующем списке типы селекторов расположены по возрастанию специфичности:

0. селекторы типов элементов (например, h1) и псевдоэлементов (например, ::before).
1. селекторы классов (например, `.example`), селекторы атрибутов (например, `[type="radio"]`) и псевдоклассов (например, `:hover`)
2. селекторы идентификаторов (например, `#example`).

Универсальный селектор (`*`), комбинаторы (`+, >, ~, ' '`) и отрицающий псевдокласс (`:not()`) не влияют на специфичность. (Однако селекторы, объявленные внутри `:not()`, влияют).
Псевдоклассы :is(), :has() и :not() принимают вес наиболее специфичного селектора внутри скобок

Стили, обьявленные в элементе (например, `style="font-weight:bold"`), всегда переопределяют любые правила из внешних файлов стилей и, таким образом, их специфичность можно считать наивысшей.

**Расчёт специфичности**

- тег и псевдоэлемент имеют специфичность 0001
- класс, псевдокласс, атрибут - 0010
- id имеет специфичность 0100
- инлайновый стиль имеет приоритет 1000

Самый правильный способ справиться со специфичностью — отказаться от возни с ней и построить систему стилей так, чтобы у всех селекторов была одна специфичность. Например, с помощью БЭМ-классов. 

Ключевое слово `!important` нарушает все установленные спецификацией законы и насильно применяет свойство, после которого написано. Ему плевать на селектор CSS-правила, внутри которого это свойство написано. Нарушает естественную работу специфичности и каскада.   

<img src="https://github.com/AntonGitCode/Front-end-Job-Interview-Questions/assets/117078390/87053c9b-42e7-4c38-92a2-54ded69d8869" width="30">  Какого цвета будет "Этот пример." ?  

html
```html  
<p id="foo">Это пример.</p>
```
css
```css
#foo {
  color: green;
}

[id="foo"] {
  color: purple;
}
```

<img src="https://github.com/AntonGitCode/Front-end-Job-Interview-Questions/assets/117078390/87053c9b-42e7-4c38-92a2-54ded69d8869" width="30"> Можно наращивать специфичность класса добавлением его же к себе же

 html
```html  
<div id="who" class="green tomato">
  Кто я?
</div>
```
css
```css
.green.green {
  color: green;
} 

.tomato {
  color: tomato;
} 
```

<img src="https://github.com/AntonGitCode/Front-end-Job-Interview-Questions/assets/117078390/2dc28c8c-3be3-4eb0-a038-1fa79de77155" width="55%">
<br>

<h2>псевдоКласс псевдоЭлементы</h2>

**Псевдокласс** выбирает элементы, находящиеся в определённом состоянии или положении в иерархии DOM.   
a:hover :checked :active :last-child  

<a name="displayvshidden"></a>
<h2>display: none  vs  visibility: hidden</h2>  

visibility: hidden, он хотя и невидим, но доступен для программ чтения экрана. Screen readers смогут прочитать содержимое этого элемента, как будто он отображается на странице.  

<a name="margincoll"></a>  
<h2>margin collapsing</h2>

Схлопывание границ (margin collapsing) - это процесс, при котором **вертикальные внешние отступы (margin) смежных блочных элементов объединяются в один отступ**.  
Внешние отступы плавающих и абсолютно позиционируемых элементов никогда не схлопываются.  

<a name="csspreproc"></a>
<h2>Что такое CSS препроцессор?</h2>

  преобразуют код, написанный с использованием препроцессорного языка, в чистый и валидный CSS-код  
  SASS LESS PostCSS  

<h2>Блочные и строчные</h2>  

Блочные элементы, такие как ```<div>, <p>, <h1>-<h6>```, представляют собой "блоки" и занимают всю доступную ширину на странице по умолчанию.  
строчные (**inline**) элементы, такие как ```<span>, <a>, <strong>``` отображаются внутри блочных элементов и не создают новых строк. Они занимают только столько места, сколько необходимо для отображения их содержимого.
**inline-block** (came with HTML5) - отображаются в одну строку, но при этом поддерживают свойства блочного форматирования, такие как ширина, высота и отступы

<a name="cssbro"></a>
<h2>Как с помощью CSS определить, поддерживается ли свойство в браузере?</h2>  

```css
@supports (display: grid) {
  /* CSS правила, применяемые только если свойство display: grid поддерживается */
  .element {
    display: grid;
  }
}
```
  
<a name="globalcss"></a>  
<h2>Глобальные ключевые слова в CSS?</h2>  

[хороша статья](https://web-standards.ru/articles/inherit-initial-unset-revert/)  
  
initial - идет как заводские настройки, далее браузер для html-элементов _натягивает_ стили-по-умолчанию.  

1. `initial`: Устанавливает значение свойства в его изначальное значение по умолчанию. Например, для свойства color значение initial всегда будет black.
2. `inherit`: Наследует значение свойства от родительского элемента.
3. `unset`: Сбрасывает значение свойства, возвращая его к изначальному значению по умолчанию, если такое значение существует, или наследует значение, если оно есть, или использует значение `initial`, если не существует ни изначального значения по умолчанию, ни наследуемого значения. Для ненаследуемых свойств unset ведет себя как initial.
4. `revert`: сбрасывает к настройкам браузера по умолчанию (не initial, а браузера).

`initial`-значение для свойства `display` равно `inline` для всех элементов. Поэтому, если для элемента <div> будет задано свойство display со значением initial, то свойство будет вычислено как inline, а не block, как в стилях браузера.  

`unset` 
**единственная причина существования нового ключевого слова unset** :  
```
.common-content {
    all: unset;
}
```

<a name="attr"></a>
<h2>Что такое CSS-атрибут (attr)?</h2>  
  
`attr()` — это **CSS-функция, которая умеет получать значение любого атрибута элемента, а потом использовать это значение прямо в стилях.**
  на данный момент уверено работает с content, у остальных надо чекать канюз  
  
```css
  div::before {
  content: attr(data-title);
  content: attr(href);
  // или с указанием типа:
  content: attr(data-width px);
}
```
<a name="selectors"></a>  
<h2>Что такое перечисление селекторов?</h2>  

перечисление стилей через зпт  

  
<a name="curcol"></a>
<h2>Для чего используется ключевое слово `currentColor` в CSS?</h2>  
  то к чему можно применить цвет делает цветом color (как бэ динамически)  
  
```css  
  button {
    color: #0d47a1;
  }

svg {
  fill: currentColor;
}
```

<a name="csss"></a>  
<h2>Какие псевдоклассы были добавлены в CSS3?</h2>   

1. :nth-child(n) - выбирает элементы, которые являются n-ыми потомками своего родителя.
2. :nth-of-type(n) - выбирает элементы определенного типа, которые являются n-ыми потомками своего родителя.
3. :first-child - выбирает элемент, который является первым потомком своего родителя.
4. :last-child - выбирает элемент, который является последним потомком своего родителя.
5. :first-of-type - выбирает первый элемент определенного типа, который является потомком своего родителя.
6. :last-of-type - выбирает последний элемент определенного типа, который является потомком своего родителя.
7. :not(selector) - выбирает элементы, которые не соответствуют указанному селектору.
8. :hover - выбирает элемент, над которым находится указатель мыши.
9. :focus - выбирает элемент, который находится в фокусе.
10. :checked - выбирает отмеченный элемент формы (например, флажок или переключатель).
11. :disabled - выбирает элементы, которые являются неактивными или заблокированными.
12. :empty - выбирает элементы, которые не содержат дочерних элементов или текстового содержимого.

<a name="cssfilters"></a>
<h2>Какие фильтры есть в CSS?</h2>  
  
1. `blur()`: применяет размытие к элементу. Значение указывает радиус размытия.
2. `brightness()`: управляет яркостью элемента. Значение 0 означает полностью черный элемент, а значение 1 означает элемент без изменений.
3. `contrast()`: управляет контрастностью элемента. Значение 0 означает полностью серый элемент, а значение 1 означает элемент без изменений.
4. `grayscale()`: делает элемент полностью серым. Значение 1 означает полностью серый элемент, а значение 0 означает элемент без изменений.
5. `hue-rotate()`: поворачивает оттенок элемента. Значение указывает угол в градусах.
6. `invert()`: инвертирует цвета элемента. Значение 0 означает элемент без изменений, а значение 1 означает полную инверсию цветов.
7. `opacity()`: управляет прозрачностью элемента. Значение 0 означает полностью прозрачный элемент, а значение 1 означает элемент без изменений.
8. `saturate()`: управляет насыщенностью элемента. Значение 0 означает полностью безцветный элемент, а значение 1 означает элемент без изменений.
9. `sepia()`: добавляет эффект сепии к элементу. Значение 1 означает полностью сепия-эффект элементу, а значение 0 означает элемент без изменений  
   
<a name="invalid"></a>
<h2>:invalid</h2>

  Псевдокласс :invalid используется для выбора элементов формы, которые содержат неверное значение или не прошли валидацию по определенным правилам.  
  

<h2>Расскажите про свойство `display` в CSS?</h2>  

определяет, как элемент должен быть показан на странице.  
позволяет контролировать тип отображения элемента и его поведение в потоке контента страницы.
  
`inline-block`, `flex`, `grid`, `table`, `none` 

<h2>когда `translate()` лучше вместо абсолютного позиционирования?</h2>  

translate
- Она **не смещает остальные элементы на странице**, поэтому изменение позиции элемента с помощью translate() может быть более предсказуемым и менее вероятным повлиять на макет в целом.
- Translate() может быть гораздо **проще использовать вместе с анимациями и переходами, так как изменение координат выполняется плавно**.
- Элемент с translate() **может остаться в потоке HTML и влиять на позиционирование других элементов**

 если вам нужно лишь немного сместить элемент или анимировать его позицию, лучше использовать translate().  

<a name="txtrendering"></a>  
<h2>`text-rendering`</h2>  
   **указывать браузеру, какие оптимизации нужно производить с текстом во время рендера.**  
   лигатуры и кернинговые пары.  
    
<a name="skipink"></a>  
<h2>`text-decoration-skip-ink`</h2>    
    
  обтекать или пересекать буквы underline  
    
<a name="pointer"></a>  
<h2>`pointer-events`</h2>  
  
свойство `pointer-events` позволяет **управлять** тем, **как элементы HTML реагируют на события указателя** (например, щелчок мыши или наведение курсора). Значение `auto` означает, что элемент будет реагировать на события указателя так же, как и обычно. Значение `none` указывает, что элемент не будет реагировать на события указателя, и события будут передаваться элементам, находящимся под ним.  
  
<a name="outln"></a>  
<h2>`outline`</h2>  

 - border на стероидах.  
 - outline не ломает верстку, показывая фокус элемента.  
 - Если рамку надо сместить то `outline` использовать совместно с `outline-offset`   
 - `outline` на самом деле это **шорткат** — короткое свойство для записи сразу нескольких значений.  
 - Внутри себя оно содержит свойства `outline-width`, `outline-style` и `outline-color`.  
 - используя border и outline можно создать множественную рамку вокруг элемента  

  Если ваш дизайнер просит сбросить обводку у элементов в фокусе, не пользуйтесь outline: none, даже если это кажется самым простым способом.
Воспользуйтесь свойством outline-color со значением transparent.  

<a name="gutter"></a>
<h2>`scrollbar-gutter`</h2>  

**решает проблему с «прыгающей» шириной контента при появлении или скрытии скроллбара**. Обычно эта проблема появляется при изменении высоты контента или появлении модального окна.  

позволяет авторам **резервировать пространство для полосы прокрутки**, предотвращая нежелательные изменения макета по мере роста содержимого, а также избегая ненужных визуальных эффектов, когда прокрутка не нужна.  
  
`auto` — дефолтное значение. Если задано overflow: scroll или overflow: auto и контент вызывает переполнение, то появится отступ для скроллбара.  
`stable` — отступ для скроллбара появляется если значение overflow равно hidden, scroll или auto, вне зависимости от того, вызывает контент переполнение или нет.  
`stable both-edges` — то же самое что и stable, но отступы будут создаваться с двух противоположных сторон. При вертикальной прокрутке — справа и слева, при горизонтальной — сверху и снизу.  
  
<a name="cssshot"></a>
<h2>Почему не стоит использовать краткую запись свойств CSS?</h2>

  - Усложнение чтения и понимания кода для других разработчиков.
- Ограничение возможности переопределения отдельных значений свойств.
- Увеличение вероятности возникновения ошибок при изменении значений.
- Ограничения совместимости с некоторыми старыми браузерами и устаревшими версиями CSS.
  
<a name="csslight"></a>  
<h2>Псевдоэлементы для подсветки текста?</h2>

   first-line first-letter  before  after  

    Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть выбранного элемента.  
    `::after`  
`::before`  
`::cue`  
`::first-letter`  
`::first-line`  
`::selection`  

  
<a name="colorcss"></a>
<h2>Способы задания цвета в CSS?</h2>

  1. **Именованные цвета**: CSS предоставляет набор предопределенных именованных цветов, таких как "red", "blue", "green" и т.д.

2. **HEX-код**: цвет может быть задан с использованием шестнадцатеричного кода, начинающегося с символа "#". Например, #FF0000 обозначает красный цвет.

3. **RGB**: цвет может быть задан с использованием RGB значений (красный, зеленый и синий). Например, rgb(255, 0, 0) задает красный цвет.

4. **RGBA**: это расширение RGB, позволяющее задать прозрачность цвета. Например, rgba(255, 0, 0, 0.5) обозначает красный цвет с полупрозрачностью 0.5.

5. **HSL и HSLA**: это еще один способ задания цвета в CSS, основанный на оттенке (Hue), насыщенности (Saturation) и светлоте (Lightness). HSLA также позволяет задать прозрачность.

<a name="transition"></a>
<h2>Какие CSS-свойства используются для создания анимаций и плавных переходов?</h2>

1. **transition**: задает плавный переход между различными состояниями элемента. Например, можно указать transition: width 1s, чтобы при изменении ширины элемента происходил плавный переход в течение 1 секунды.

2. **animation**: позволяет создавать сложные анимации с помощью задания набора ключевых кадров (keyframes). Например, можно использовать animation: myAnimation 2s infinite, чтобы анимация с названием "myAnimation" продолжалась 2 секунды и повторялась бесконечно.

3. **transform**: используется для применения различных трансформаций к элементу, таких как смещение (translate), поворот (rotate), масштабирование (scale) и т.д. Трансформации можно комбинировать и анимировать для создания сложных эффектов.

4. **opacity**: позволяет изменять прозрачность элемента. Можно анимировать свойство opacity для создания плавных переходов от полностью прозрачного состояния к полностью видимому и наоборот.

5. **@keyframes**: используется для определения набора ключевых кадров (анимаций) с заданными свойствами для анимации. Можно задать различные состояния элемента в разные моменты времени и задать интерполяцию между ними.
   
<a name="cssscale"></a>
<h2>Принципы и подходы для обеспечения масштабируемости и поддерживаемости CSS-кода</h2>  
  
1. **Использование модульных стилей**: разделение стилей на небольшие модули или компоненты помогает улучшить читаемость и облегчить поддержку кода. Каждый модуль должен быть автономным и легко адаптируемым для использования в других частях проекта.

2. **Набор правил при наименьшем числе селекторов**: старайтесь использовать минимальное количество селекторов для определения стилей. Это помогает избежать конфликтов и упрощает изменения структуры HTML-разметки без внесения изменений в CSS.

3. **Использование вендорных префиксов** для поддержки браузеров: чтобы обеспечить совместимость с различными браузерами, рекомендуется использовать префиксы CSS-свойств, такие как -webkit-, -moz-, -ms- и т.д. Это позволяет применять определенные стили для определенных браузеров.

4. **Использование переменных**: CSS-переменные (CSS Custom Properties) позволяют определить набор значений и повторно использовать их в различных частях кода. Это сделает ваш CSS гибким и упрощает его поддержку.

5. **Применение методологий организации кода**: использование методологий, таких как BEM (Block, Element, Modifier) или SMACSS (Scalable and Modular Architecture for CSS), помогает структурировать и организовать CSS-код, сделав его более понятным и легко поддерживаемым.

6. **Комментирование кода**: добавление комментариев к CSS-коду помогает другим разработчикам понять его назначение и функциональность, упрощая поддержку и разработку.

7. **Использование сборщиков и препроцессоров**: использование инструментов, таких как Sass, Less или PostCSS, позволяет вам использовать множество полезных функций и возможностей, таких как переменные, миксины, импорт файлов и многое другое. Это помогает в создании более эффективного и поддерживаемого CSS-кода.
  
<a name="bemwtf"></a>
<h2>Плюсы и минусы методологии БЭМ?</h2>

Плюсы методологии БЭМ (Блок-Элемент-Модификатор) в программировании веб-интерфейсов:  
  
1. **Модульность**: БЭМ позволяет разбить интерфейс на независимые блоки, что упрощает разработку и поддержку кода.
2. **Понятность**: Благодаря стандартным названиям классов и ясной иерархии, код на БЭМ легко читается и понимается другими разработчиками.
3. **Повторное использование**: Блоки, элементы и модификаторы могут быть повторно использованы на разных страницах, что способствует эффективному внедрению и сокращению объема кода.
4. **Расширяемость**: БЭМ позволяет легко добавлять новые блоки или модификаторы и модифицировать существующие без необходимости переписывания всего кода.
  
Несколько **минусов методологии БЭМ**:
  
1. **Избыточность кода**: Использование длинных иерархических классов в коде может привести к избыточности и повышенному объему кода.
2. **Сложность для начинающих**: Начинающим разработчикам может потребоваться время для понимания и освоения концепций и правил БЭМ.
3. **Нестандартное использование**: Некоторые разработчики могут использовать методологию БЭМ не полностью или собственным, нестандартным образом, что может вызывать проблемы совместной работы и поддержки кода.
     
<a name="sass"></a>
<h2>Какие CSS-препроцессоры вы знаете? Преимущества их использования?</h2>

  1. Переменные: Препроцессоры позволяют использовать переменные, что делает управление цветами, шрифтами или другими стилями более гибким и облегчает изменения на всех страницах проекта.

Пример:
```
$primary-color: #3f51b5;
$secondary-color: #ff4081;

.button {
  background-color: $primary-color;
  color: $secondary-color;
}
```

2. Вложенность: Препроцессоры позволяют вкладывать стили в другие стили, что повышает читаемость и организацию кода.

Пример:
```
.navbar {
  background-color: #f5f5f5;
  
  .logo {
    width: 150px;
    height: 50px;
  }
  
  .menu {
    padding: 10px;
    
    li {
      display: inline-block;
      margin-right: 10px;
    }
  }
}
```

3. Миксины: Миксины позволяют определять набор стилей для повторного использования. Это может быть полезно, например, для создания префиксов браузерных свойств или для создания стилей для разных состояний элементов.

Пример:
```
@mixin transition($property) {
  -webkit-transition: $property;
  -moz-transition: $property;
  -o-transition: $property;
  transition: $property;
}

.button {
  @include transition(all 0.3s);
}
```

4. Функции: CSS-препроцессоры также предлагают различные функции, которые можно использовать для облегчения вычислений и манипуляции со значениями.

Пример:
```
@function calculate-grid-width($columns, $gutter) {
  @return ($columns * 100%) + ($gutter * ($columns - 1));
}

.container {
  width: calculate-grid-width(12, 20px);
}
```

5. Импортирование: Препроцессоры позволяют импортировать файлы CSS и другие стили из других файлов, что помогает структурировать код и упрощает его поддержку.

Пример:
```
// В файле main.scss
@import 'variables';
@import 'layout';
@import 'buttons';

// В файле _variables.scss
$primary-color: #3f51b5;
$secondary-color: #ff4081;
```

Использование CSS-препроцессоров повышает эффективность и гибкость разработки стилей, делая код более поддерживаемым и масштабируемым. Они также предоставляют множество дополнительных функций, которые упрощают и ускоряют процесс разработки.
