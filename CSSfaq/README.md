

- [Что такое CSS? И для чего он используется?](https://youtu.be/ycYp7CYOnO0?t=251)
- [Что такое CSS-правило?](https://youtu.be/CjdCxxqObaM?t=228)
- [Варианты добавление CSS стилей на страницу?](https://youtu.be/ycYp7CYOnO0?t=277)
- [Типы позиционирования в CSS?](https://youtu.be/ycYp7CYOnO0?t=321)
- [Блочная модель CSS?](https://youtu.be/ycYp7CYOnO0?t=410)
- [Что такое селектор? И какие селекторы существуют?](https://youtu.be/G7hLwudGWL4?t=282)
- [Что такое специфичность селектора? Как считать вес селектора?](https://youtu.be/G7hLwudGWL4?t=358)
- [Разница между Reset.css и Normalize.css?](https://youtu.be/G7hLwudGWL4?t=445)
- [Разница между `margin` и `padding`?](https://youtu.be/1eIRTdgzHtw?t=116)
- [Разница между `display: none` и `visibility: hidden`?](https://youtu.be/1eIRTdgzHtw?t=139)
- [Разница между блочным и строчным (инлайновым) элементами?](https://youtu.be/1eIRTdgzHtw?t=188)
- [Разница между классом и идентификатором в CSS?](https://youtu.be/CjdCxxqObaM?t=264)
- [Что такое CSS спрайт? И для чего он используется?](https://youtu.be/CjdCxxqObaM?t=330)
- [Что такое вендорные префиксы? И для чего они используются?](https://youtu.be/rlWgI7AvV18?t=234)
- [Что такое псевдоэлементы? И для чего они используются?](https://youtu.be/rlWgI7AvV18?t=355)
- [Что такое схлопывание границ (margin collapsing)?](https://youtu.be/kx3dR6ztICU?t=30)
- [Что такое CSS препроцессор?](https://youtu.be/kx3dR6ztICU?t=159)
- [Что такое `z-index`? Как формируется контекст наложения?](https://youtu.be/GZUy2i6QN7o?t=102)
- [Порядок наложения элементов в CSS (Stacking Order)?](https://youtu.be/GZUy2i6QN7o?t=204)
- [Как с помощью CSS определить, поддерживается ли свойство в браузере?](#cssbro)
- [Как поддерживать страницы в браузерах с ограниченными функциями?](https://youtu.be/70VnuTXi4Wk?t=75)
- [Как исправлять специфичные проблемы со стилями для разных браузеров?](https://youtu.be/70VnuTXi4Wk?t=122)
- [Глобальные ключевые слова в CSS?](#globalcss)
- [Что такое CSS-атрибут (`attr`)?](#attr)
- [Что такое перечисление селекторов?](https://youtu.be/VYQl2GhbCUs?t=336)
- [Для чего используется ключевое слово `currentColor` в CSS?](https://youtu.be/trriSYNrHw4?t=549)
- [Какие псевдоклассы были добавлены в CSS3?](https://youtu.be/trriSYNrHw4?t=592)
- [Какие фильтры есть в CSS?](https://youtu.be/trriSYNrHw4?t=662)
- [Для чего используется псевдокласс `:invalid`?](https://youtu.be/xIGp2FCxqj0?t=370)
- [Расскажите про свойство `display` в CSS?](https://youtu.be/xIGp2FCxqj0?t=436)
- [В каком случае лучше использовать `translate()` вместо абсолютного позиционирования?](https://youtu.be/xIGp2FCxqj0?t=543)
- [Что такое плавающие элементы (floats)? Как они работают?](https://youtu.be/xIGp2FCxqj0?t=610)
- [Расскажите о свойстве `text-rendering`?](https://youtu.be/nbWY5W-9OEo?t=35)
- [Расскажите о свойстве `text-decoration-skip-ink`?](https://doka.guide/css/text-decoration-skip-ink/)
- [Расскажите о свойстве `pointer-events`?](https://youtu.be/J6CgOSKFOlw?t=336)
- [Расскажите о свойстве `outline`?](#outln)
- [Расскажите о свойстве `scrollbar-gutter`?](#scrlgtr)
- [Почему не стоит использовать краткую запись свойств CSS?](https://youtu.be/3NGkctg4lsE?t=404)
- [Назовите псевдоэлементы для подсветки текста?](https://youtu.be/3NGkctg4lsE?t=584)
- [Способы задания цвета в CSS?](https://youtu.be/hL5yFo9Pms4?t=384)
- [Какие CSS-свойства используются для создания анимаций и плавных переходов?](https://youtu.be/DZjIcc6KdjE?t=29)
- [Принципы и подходы для обеспечения масштабируемости и поддерживаемости CSS-кода?](https://youtu.be/DZjIcc6KdjE?t=93)
- [Плюсы и минусы методологии БЭМ?](https://youtu.be/DZjIcc6KdjE?t=174)
- [Какие CSS-препроцессоры вы знаете? Преимущества их использования?](https://youtu.be/DZjIcc6KdjE?t=250)

<h2>Что такое CSS?</h2>
  
CSS (Cascading Style Sheets) - это язык стилей, используемый для описания внешнего вида и форматирования документа, написанного с использованием языка разметки, такого как HTML или XML. Основная цель CSS - разделить контент от его представления, что позволяет легко изменять стиль и макет веб-страницы без изменения ее содержимого.  
  
С помощью CSS можно задавать различные свойства элементов веб-страницы, такие как цвет фона, шрифт, размер, отступы, выравнивание, рамки и другие стилизационные аспекты. Он также позволяет создавать анимации, применять трансформации и определять адаптивное поведение элементов на разных устройствах и размерах экранов.  
  
CSS используется для придания визуального оформления веб-страницам, делая их более привлекательными и удобочитаемыми.  

<h2>Варианты добавление CSS стилей на страницу?</h2>  

  1. Встроенные стили. с помощью style в head, или внутри тега  ``` <h1 style="color: blue; font-size: 24px;">Привет, мир!</h1>```  
  2. Внешние файлы стилей. в html: ```<link rel="stylesheet" href="styles.css">```  

```html
<!DOCTYPE html>
<html>
<head>
    <title>Моя страница</title>
    <style>
        h1 {
            color: blue;
            font-size: 24px;
        }
        p {
            color: green;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <h1>Привет, мир!</h1>
    <p>Это моя страница.</p>
</body>
</html>
```

<h2>Типы позицинирования</h2>

  1. **Static** (Статическое позиционирование): это значение позиционирования по умолчанию для всех элементов. Элементы с таким позиционированием выводятся в порядке, заданном в коде их разметки, и не затрагивают позиционирование других элементов.

2. **Relative** (Относительное позиционирование): с помощью этого типа позиционирования элементы можно сдвигать относительно их исходного местоположения. Они все еще занимают свое место в потоке документа, но их позиция может быть изменена с помощью сдвига относительно себя или других элементов.
 
3. **Absolute** (Абсолютное позиционирование): элементы с абсолютным позиционированием полностью удалены из нормального потока документа и помещаются в определенное место на странице. Они позиционируются относительно ближайшего элемента с позиционированием, отличным от статического (если такого элемента нет, то относительно самого окна просмотра). При использовании абсолютного позиционирования элементы выходят из нормального потока и не занимают пространство для других элементов.

4. **Fixed** (Фиксированное позиционирование): элементы с фиксированным позиционированием фиксируются относительно окна просмотра, то есть они останутся на месте, даже при прокрутке страницы. Они также выходят из нормального потока.

5. **Sticky** (Прилипающее позиционирование): элементы с прилипающим позиционированием начинают залипать (приклеиваться) к определенной позиции на странице при достижении этой позиции при прокрутке. Они остаются в потоке документа и занимают свое место, пока не достигнут нужной позиции.

<h2>Блочная модель</h2>  
  
Блочная модель CSS состоит из следующих компонентов:  
  
1. **Content** (Содержимое): это часть элемента, которая содержит его реальное содержимое, такое как текст, изображения, видео и т. д. Ширина и высота содержимого задаются с помощью свойств width и height.  
  
2. **Padding** (Внутренние отступы): это пространство между содержимым элемента и его границей. Отступы определяются с помощью свойств padding-top, padding-right, padding-bottom и padding-left.  
  
3. **Border** (Границы): это линия, окружающая содержимое элемента и отделяющая его от других элементов. Границы могут быть заданы с помощью свойств border-width, border-style и border-color.  
  
4. **Margin** (Внешние отступы): это пространство вокруг элемента, которое разделяет его соседние элементы. Отступы определяются с помощью свойств margin-top, margin-right, margin-bottom и margin-left.  

<h2>Что такое селектор? И какие селекторы существуют?</h2>  

  **Селектор** - **это часть CSS правила, которая указывает, на какие элементы веб-страницы должны быть применены определенные стили или свойства.**

Существуют различные **типы селекторов** в CSS:

- Универсальный селектор
-  по тегу (элементу)
-  по идентификатору (id) #id
-  по классу (class) .className
- по атрибуту [attr]
- Группа селекторов  , ,

<img src="https://github.com/AntonGitCode/FEFAQ/assets/117078390/e16b25fe-1d69-4c18-b60a-0d132d7f6c8d" width=450>  
  
<h2>Специфичность селекторов</h2>

**Специфичность** — _это алгоритм, благодаря которому браузер определяет, какие именно стили из всего набора применить к элементу._  
 **```EN```** specificity 
   
В следующем списке типы селекторов расположены по возрастанию специфичности:

0. селекторы типов элементов (например, h1) и псевдоэлементов (например, ::before).
1. селекторы классов (например, `.example`), селекторы атрибутов (например, `[type="radio"]`) и псевдоклассов (например, `:hover`)
2. селекторы идентификаторов (например, `#example`).

Универсальный селектор (`*`), комбинаторы (`+, >, ~, ' '`) и отрицающий псевдокласс (`:not()`) не влияют на специфичность. (Однако селекторы, объявленные внутри `:not()`, влияют).
Псевдоклассы :is(), :has() и :not() принимают вес наиболее специфичного селектора внутри скобок

Стили, обьявленные в элементе (например, `style="font-weight:bold"`), всегда переопределяют любые правила из внешних файлов стилей и, таким образом, их специфичность можно считать наивысшей.

**Расчёт специфичности**

- тег и псевдоэлемент имеют специфичность 0001
- класс, псевдокласс, атрибут - 0010
- id имеет специфичность 0100
- инлайновый стиль имеет приоритет 1000

Самый правильный способ справиться со специфичностью — отказаться от возни с ней и построить систему стилей так, чтобы у всех селекторов была одна специфичность. Например, с помощью БЭМ-классов. 

Ключевое слово `!important` нарушает все установленные спецификацией законы и насильно применяет свойство, после которого написано. Ему плевать на селектор CSS-правила, внутри которого это свойство написано. Нарушает естественную работу специфичности и каскада.   

<img src="https://github.com/AntonGitCode/Front-end-Job-Interview-Questions/assets/117078390/87053c9b-42e7-4c38-92a2-54ded69d8869" width="30">  Какого цвета будет "Этот пример." ?  

html
```html  
<p id="foo">Это пример.</p>
```
css
```css
#foo {
  color: green;
}

[id="foo"] {
  color: purple;
}
```

<img src="https://github.com/AntonGitCode/Front-end-Job-Interview-Questions/assets/117078390/87053c9b-42e7-4c38-92a2-54ded69d8869" width="30"> Можно наращивать специфичность класса добавлением его же к себе же

 html
```html  
<div id="who" class="green tomato">
  Кто я?
</div>
```
css
```css
.green.green {
  color: green;
} 

.tomato {
  color: tomato;
} 
```

<img src="https://github.com/AntonGitCode/Front-end-Job-Interview-Questions/assets/117078390/2dc28c8c-3be3-4eb0-a038-1fa79de77155" width="55%">
<br>

<h2>псевдоКласс псевдоЭлементы</h2>

**Псевдокласс** выбирает элементы, находящиеся в определённом состоянии или положении в иерархии DOM.   
a:hover :checked :active :last-child  

<h2>display: none  vs  visibility: hidden</h2>  

visibility: hidden, он хотя и невидим, но доступен для программ чтения экрана. Screen readers смогут прочитать содержимое этого элемента, как будто он отображается на странице.  

<h2>:invalid</h2>

  Псевдокласс :invalid используется для выбора элементов формы, которые содержат неверное значение или не прошли валидацию по определенным правилам.  

<h2>margin collapsing</h2>

Схлопывание границ (margin collapsing) - это процесс, при котором **вертикальные внешние отступы (margin) смежных блочных элементов объединяются в один отступ**.  
Внешние отступы плавающих и абсолютно позиционируемых элементов никогда не схлопываются.  

<h2>Что такое CSS препроцессор?</h2>

  преобразуют код, написанный с использованием препроцессорного языка, в чистый и валидный CSS-код  
  SASS LESS PostCSS  

<h2>Блочные и строчные</h2>  

Блочные элементы, такие как ```<div>, <p>, <h1>-<h6>```, представляют собой "блоки" и занимают всю доступную ширину на странице по умолчанию.  
строчные (**inline**) элементы, такие как ```<span>, <a>, <strong>``` отображаются внутри блочных элементов и не создают новых строк. Они занимают только столько места, сколько необходимо для отображения их содержимого.
**inline-block** (came with HTML5) - отображаются в одну строку, но при этом поддерживают свойства блочного форматирования, такие как ширина, высота и отступы

<a name="cssbro"></a>
<h2>Как с помощью CSS определить, поддерживается ли свойство в браузере?</h2>  

```css
@supports (display: grid) {
  /* CSS правила, применяемые только если свойство display: grid поддерживается */
  .element {
    display: grid;
  }
}
```

<h2>pointer-events</h2>
  
свойство `pointer-events` позволяет **управлять** тем, **как элементы HTML реагируют на события указателя** (например, щелчок мыши или наведение курсора). Значение `auto` означает, что элемент будет реагировать на события указателя так же, как и обычно. Значение `none` указывает, что элемент не будет реагировать на события указателя, и события будут передаваться элементам, находящимся под ним.  
  
<a name="outln"></a>  
<h2>outline</h2>  

  border на стероидах.  
  outline не ломает верстку, показывая фокус элемента.  
  Если рамку надо сместить то `outline` использовать совместно с `outline-offset`   
  `outline` на самом деле это **шорткат** — короткое свойство для записи сразу нескольких значений.  
  Внутри себя оно содержит свойства `outline-width`, `outline-style` и `outline-color`.  
  используя border и outline можно создать множественную рамку вокруг элемента  

  Если ваш дизайнер просит сбросить обводку у элементов в фокусе, не пользуйтесь outline: none, даже если это кажется самым простым способом.
Воспользуйтесь свойством outline-color со значением transparent.  
  
<a name="globalcss"></a>  
<h2>Глобальные ключевые слова в CSS?</h2>  

[хороша статья](https://web-standards.ru/articles/inherit-initial-unset-revert/)  
  
initial - идет как заводские настройки, далее браузер для html-элементов _натягивает_ стили-по-умолчанию.  

1. `initial`: Устанавливает значение свойства в его изначальное значение по умолчанию. Например, для свойства color значение initial всегда будет black.
2. `inherit`: Наследует значение свойства от родительского элемента.
3. `unset`: Сбрасывает значение свойства, возвращая его к изначальному значению по умолчанию, если такое значение существует, или наследует значение, если оно есть, или использует значение `initial`, если не существует ни изначального значения по умолчанию, ни наследуемого значения. Для ненаследуемых свойств unset ведет себя как initial.
4. `revert`: сбрасывает к настройкам браузера по умолчанию (не initial, а браузера).

`initial`-значение для свойства `display` равно `inline` для всех элементов. Поэтому, если для элемента <div> будет задано свойство display со значением initial, то свойство будет вычислено как inline, а не block, как в стилях браузера.  

`unset` 
**единственная причина существования нового ключевого слова unset** :  
```
.common-content {
    all: unset;
}
```

<a name="attr"></a>
<h2>Что такое CSS-атрибут (attr)?</h2>  
  
`attr()` — это **CSS-функция, которая умеет получать значение любого атрибута элемента, а потом использовать это значение прямо в стилях.**
  на данный момент уверено работает с content, у остальных надо чекать канюз  
  
```css
  div::before {
  content: attr(data-title);
  content: attr(href);
  // или с указанием типа:
  content: attr(data-width px);
}
```

  
