<h3>
  <img src="../assets/WWW.png" width="16" height="16" />
  <span>Web Technologies:</span>
</h3>

- [Что такое прогрессивный рендеринг?](#prorender)  
- [Что такое прогрессивный SSR?](https://youtu.be/trriSYNrHw4?t=25)
- [Что такое Progressive Web Application (PWA)?](#pwa)
- [Что такое кроссбраузерность?](https://youtu.be/kx3dR6ztICU?t=90)
- [Что такое OSI модель?](#osi)
- [Что такое поток документа?](https://youtu.be/trriSYNrHw4?t=102)
- [Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?](https://youtu.be/1eIRTdgzHtw?t=233)
- [Разница между Progressive Enhancement и Graceful Degradation?](https://youtu.be/rlWgI7AvV18?t=286)
- [Что такое Веб-компоненты и какие технологии в них используются?](https://youtu.be/G4iYlbilozM?t=704)
- [Особенности разработки мультиязычных сайтов?](https://youtu.be/yvOXvZ8aEFo?t=82)
- [Что такое REST?](https://youtu.be/ovV8GhIkzBE?t=352)
- [Что такое REST и RESTful api?](https://youtu.be/__neFkxAO9s?t=334)
- [Принципы REST-архитектуры?](https://youtu.be/-mWa7erZu64?t=159)
- [Что такое модель зрелости Ричардсона?](https://youtu.be/-mWa7erZu64?t=30)
- [Основные уровни модели зрелости Ричардсона?](https://youtu.be/-mWa7erZu64?t=73)
- [Назовите критические этапы рендеринга?](https://youtu.be/3NGkctg4lsE?t=31)
- [Разница между layout, painting и compositing?](https://youtu.be/yvOXvZ8aEFo?t=209)
- [Что такое Flash Of Unstyled Content (FOUC)? Как его избежать?](https://youtu.be/yvOXvZ8aEFo?t=164)
- [Что такое History API в браузере?](https://youtu.be/XtQPrt8G0n8?t=352)
- [Что такое веб-хранилище (web storage)?](https://youtu.be/XtQPrt8G0n8?t=406)
- [Разница между `cookie`, `sessionStorage` и `localStorage`?](https://youtu.be/nvktMVFM0_M?t=604)
- [Способы уменьшения времени загрузки веб-страницы?](https://youtu.be/nvktMVFM0_M?t=678)
- [Что такое Core Web Vitals? Какие основные метрики туда входят?](https://youtu.be/DQ0BLu6rZYc?t=214)
- [Расскажите о метриках Core Web Vitals?](https://youtu.be/DQ0BLu6rZYc?t=314)
- [Разница между `preload`, `prefetch`, `preconnect` и `prerender`?](https://youtu.be/DQ0BLu6rZYc?t=410)
- [Для чего нужен паттерн PRPL?](https://youtu.be/DQ0BLu6rZYc?t=519)
    
 ```

``` 
<h3> Ответы </h3>  
<a name="prorender"></a>    
<h2>Что такое прогрессивный рендеринг?</h2>  

  Прогрессивный рендеринг - это **обобщенное название технологий, которые используются для ускорения отрисовки веб страниц.** 
  Основная идея - это как можно раньше показать пользователю визуальный контент.  
  Цель - уменьшить время загрузки веб-страницы.  

Примеры технологий:  
    - ленивая загрузка изображений,  
    - приоритизация видимого контента,  
    - отложенные скрипты,  
    - асинхронные фрагменты  HTML.  
    
(PageSpeed Insights)

**технологии прогрессивного рендеринга**  
   
1. **Ленивая загрузка (lazy load) изображений**: позволяет загружать изображения только тогда, когда они попадают в область видимости пользователя на странице. Это можно реализовать с помощью JavaScript, обнаруживая события прокрутки страницы или изменения размера окна и загружая, при необходимости, изображения через AJAX-запросы . Вы также можете использовать атрибуты HTML, такие как "data-src" для сохранения URL-адресов изображений, и динамически заменять значения атрибутов для загрузки изображений при определенных условиях.  

2. **Приоритизация видимого контента**: предполагает загрузку в первую очередь самого важного контента на странице, такого как текст, стили и основные HTML-элементы. Затем, после загрузки основного контента, можно начать загружать остальные элементы страницы. Для этого можно использовать техники асинхронной загрузки ресурсов: использование атрибута "async" для скриптов или асинхронной загрузки стилей. Это можно реализовать, добавляя дополнительные атрибуты и заголовки к вашему HTML/CSS, которые указывают на порядок загрузки ресурсов или использовать инструменты оптимизации, которые автоматически анализируют вашу страницу и оптимизируют порядок загрузки.
   `<script src="script.js" async></script>`,   `<link rel="preload" href="styles.css" as="style">`  

4. **Отложенные скрипты**:  позволяют загружать и запускать скрипты после полной загрузки и отображения основного контента на странице. Это может быть полезно для скриптов, которые не влияют на первоочередные операции и требуют больше времени для выполнения. Для отложенной загрузки и выполнения скриптов вы можете использовать атрибут "defer" для скриптов, чтобы указать браузеру, что он может продолжать загружать остальную часть страницы и выполнять другой код, пока не будет достигнут порядок отложенных скриптов.  

5. **Асинхронные фрагменты HTML**: позволяют загружать отдельные куски HTML-кода асинхронно. Это может быть полезно, если у вас есть отдельные компоненты или виджеты, которые можно загрузить и встроить в основной контент страницы в разное время. Вы можете использовать JavaScript и библиотеки шаблонизации, чтобы загрузить и вставить эти фрагменты HTML в страницу при необходимости.  

```

```

<h2>Прогрессивный рендеринг на стороне сервера</h2>  
SSR (Server-Side Rendering)  
Прогрессивный рендеринг на стороне сервера основан на концепции потоковой передачи HTML, он разбивает страницы на осмысленные самостоятельные компоненты с помощью разделения кода. Эти части страницы управляются разными скриптами, в результате чего появляется возможность сделать гидратацию независимо.  
  
  _"гидратация" означает процесс добавления или активации интерактивных элементов на веб-странице после их начальной загрузки. Когда говорят о "гидратации независимо", имеют в виду, что теперь есть возможность активировать/инициализировать каждый компонент страницы независимо от остальных, то есть без необходимости ждать полной загрузки всех компонентов. Это помогает ускорить отображение интерактивности на веб-странице и повысить общую производительность._  
  
**Основные этапы**: 
1. Браузер запрашивает у сервера HTML-код. Сервер получает запрос и начинает выполнение.
2. **Сервер делает API запросы и сначала рендерит критический контент**, а затем отправляет его клиенту. (Сервер анализирует запрошенную страницу и выделяет ее содержимое на разные уровни приоритетности. Некоторые части контента могут быть оценены как критически важные и должны быть возвращены клиенту как можно быстрее.)
3. Браузер анализирует HTML и отображает его на экране.
4. **Сервер рендерит некритический контент** и передает его браузеру.
5. Затем браузер анализирует и отображает некритичный контент.
6. **Между тем JS-бандлы загружаются и выполняются в фоновом режиме, а браузер передаёт интерактивность элементам DOM**.
  
Прогрессивный рендеринг +  
  + повышает производительность веб-приложения извлекая и визуализируя компоненты страницы параллельно.
  + уменьшает нагрузку на клиентское устройство

```

```

<h2>Разница между SSR и SSG и CSR?</h2> 
  
**SSR (Server-Side Rendering)** и **SSG (Static Site Generation)** - это два подхода к генерации веб-страниц. 

**SSR** (Server-Side Rendering) означает, что HTML страницы на каждый запрос генерируются на сервере и отправляются на клиентский браузер уже готовыми. Это позволяет улучшить SEO, так как поисковые роботы видят полный контент страницы, а также ускорить первоначальную загрузку страницы. Фреймворки, которые реализуют server rendering - Next.js

Реализуется с помощью [getServerSideProps](https://nextjs.org/docs/pages/api-reference/functions/get-server-side-props), которые потом передаются в пропс компоненту.  
```javascript
import { getServerSideProps } from 'next'
import axios from 'axios'
//////////////////////////////
export const getServerSideProps = async (context) => {
  // Получаем данные из строки запроса
  const { id } = context.query

  // Получаем данные с внешнего API
  const res = await axios.get(`https://api.example.com/data/${id}`)
  const data = res.data

  // Передаем данные на страницу через объект props
  return { props: { data } }
}
//////////////////////////////
export default function Page({ data }) {
  // Рендерим данные на странице
  return <div>{data.title}</div>
}
```
  

Плюсы: Отрисовка быстрая  

**SSG** (Static Site Generation) означает, что HTML страницы генерируются на стадии сборки проекта и сохраняются в виде статических файлов. Это позволяет ускорить загрузку страницы, так как сервер не нужно генерировать страницу каждый раз при запросе, а также уменьшить нагрузку на сервер.  
Основное отличие между SSR и SSG заключается в том, что SSR генерирует страницы динамически на каждый запрос, а SSG генерирует страницы статически на этапе сборки проекта.  
Также в SSR все запросы происходят на сервере, а у SSG на клиенте.  

**CSR** (Client Side Rendering)- на стороне клиента -  используются со всеми популярными фреймворками. Ресурсы загружаются единожды, весь бандл, html css. Весь рендер происходит в браузере. _Минусы_ - долгое время загрузки первичное, пустой html изначально, слабое SEO. _Плюсы+_ - весь процесс работы с API на стороне клиента. Может быть закешировано.  
Экономия ресурсов сервера.  


```

```

<h2>Что такое поток документа?</h2> 

**Поток** - это принцип организации элементов на странице, при отсутствии стилей.  
  
Даже если мы не стилизуем страницу при помощи CSS, то отображение элементов в браузере будет предсказуемо, так как у тегов есть стили по умолчанию, зашитые в движок браузера. Благодаря ним заголовок **h1** больше заголовка **h2**, а ссылка синие и подчеркнутые.  
На основании этих правил все элементы на странице можно разделить на 2 категории: **блочные**(div) и **строчные**(span). Изменить стандартное поведение можно при помощи CSS свойства display - absolute, fixed, sticky.  
Также в CSS есть свойство, которое вырывает элемент из нормального потока документа, к таким свойствам можно отнести **float** и **position**.  

```

```

<h2>Разница между адаптивным(adaptive) и отзывчивым(responsive) дизайнами?</h2>  

  основное отличие между этими приёмами:  
  — отзывчивый дизайн — один макет для всех устройств  
  — адаптивный дизайн — один макет для каждого вида устройства  

**Адаптивный дизайн** - это по сути несколько версий одного и того же сайта, которые загружаются в зависимости от того на каком устройстве открыт сайт. В адаптивном дизайне есть несколько версий html js css файлов одной и той же страницы.  

**Отзывчивый дизайн** - это более широкий подход, при котором веб-страница реагирует на действия пользователя и обновляется динамически без перезагрузки страницы. Это может включать в себя мгновенное изменение размеров, цветов, добавление или удаление элементов веб-страницы и т.д. Отзывчивый дизайн (Responsive Web Design) объединяет в себе три методики — гибкий макет на основе сетки, гибкие изображения и медиазапросы.  Размеры задаются относительные - в %.   
```

```  
<h2>Разница между Progressive Enhancement и Graceful Degradation?</h2>  

Эти оба подхода используются для создания кроссплатформенных и кроссбраузерных приложений.  
**Progressive Enhancement** - предполагает поэтапное создание веб интерфейсов от простого к сложному, на каждом из этапов создается законченный веб интерфейс как улучшенная версия предыдущего (от mobile до desktop).  
**Graceful Degradation** - функционал сайта деградирует от сложного к более простому. Сначала создается максимально функциональная версия веб страницы в современном браузере, а затем идет деградация до более ранних версий.  
```

```
<a name="osi"></a> 
<h2> Что такое OSI-моедль </h2>  

<img src="https://github.com/AntonGitCode/FEFAQ/assets/117078390/3b9051ae-c74e-4aff-8979-fb766b8260c8" alt="Image Description" width="550">  

![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/1db5424f-8699-433b-84f2-da4a9e962cd2)  
  
![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/73d0e38e-a301-4905-b077-58d1293e719b)

<h2>Что такое кроссбраузерность?</h2>  

**Кроссбраузерность** - это корректная адаптивная верстка для правильного отображения сайта или приложения в разных браузерах и на разных устройствах. 
Подходы для создания кроссбраузерного сайта: семантическая верстка, использование reset или normalize css, добавление вендорных префиксов, использование полифилов и транспайлиров по типу Babel.  
  ```

```
<h2>Вендорные префиксы</h2>  

Часто разработчики топовых браузеров внедряют новые свойства css, которые еще не стандартизированы. Эти свойства предваряются специальными приставками, которые называются «вендорные префиксы». Каждый браузер имеет свой префикс:  
  
-o- — префикс для браузера Опера  
-moz- — префикс для браузера Mozilla  
-ms — префикс для Internet Explorer  
-webkit- — префикс для браузеров, построенных на движке Webkit, таких, как Safari и Chrome  
 ```

``` 
<h2>Что такое Babel и для чего он используется?</h2>  

Babel - это транспайлер, который **переписывает код с современного стандарта JavaScript на более ранний**, программа позволяющая менять исходный код одной программы на эквивалентный код на другом языке.  
Основная идея: Ecma International каждый год выпускает обновления для JS, однако эти обновления внедряются в браузер постепенно, чтобы не терять время и сразу начать использовать новые фичи, которые зачастую упрощают разработку используется Babel, которые транслирует язык на более ранний для лучшей кроссбраузерности.  
```

```
<h2>Разница между feature detection, feature inference и анализом строки user-agent?</h2>  

**Feature detection** (определение возможностей браузера) - заключается в определении поддерживает ли браузер определенный блок кода, и если блок не поддерживается, то будет выполнен аналог, либо полифил, такой подход помогает обеспечить работоспособность, и предотвратить сбои и ошибки.  
  
  ![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/4c5dc9ed-8a68-49e5-b892-1ec9b5396935)  
   
  или  
```javascript
// Feature detection - проверяем поддерживает ли браузер метод addEventListener
if (window.addEventListener) {
  // Если поддерживает, то добавляем обработчик события
  window.addEventListener('load', function() {
    console.log('Страница загружена!');
  });
} else {
  // Если не поддерживает, используем альтернативный способ
  window.onload = function() {
    console.log('Страница загружена!');
  };
}
```

  
**Feature inference** (определение возможностей) - это проверка на наличие определенных возможностей, подход применяет функцию, которая предполагает, что определенная возможность уже существует. Если фича Х работает, то и фича У должна работать.  

  ![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/cc1bd96a-f119-40b3-a475-90868e80abd4)  
    

  
**User-agent** - строка сообщаемая браузером, которая позволяет определить: тип приложения, операционную систему, поставщика ПО. Доступ к ней можно получить через **navigator.userAgent**.
Рекомендуется использовать первый вариант, так как ненадежность (user-agent строки могут быть поддельными или измененными) и сложность поддержки (браузеры могут изменять формат user-agent строки).  

```
  
```
  
<h2>Что такое Веб-компоненты и какие технологии в них используются?</h2>  

**Веб-компоненты** - это технология, которая позволяет создавать многократно используемые компоненты в веб документах и приложениях, они поддерживаются браузерами напрямую и не требуют библиотек для работы.  

_html templates_  
Встроенный элемент <template> предназначен для хранения шаблона HTML. Браузер полностью игнорирует его содержимое, проверяя лишь синтаксис, но мы можем использовать этот элемент в JavaScript, чтобы создать другие элементы.  

_html import_   
custom elements  
```
class MyElement extends HTMLElement {  
  constructor() {  
    super();
    // элемент создан
  }
```
  
_shadow dom_  
Теневой DOM – это способ создать свой, изолированный, DOM для компонента.  
shadowRoot = elem.attachShadow({mode: open|closed}) – создаёт теневой DOM для elem. Если mode="open", он доступен через свойство elem.shadowRoot.  
Мы можем создать подэлементы внутри shadowRoot с помощью innerHTML или других методов DOM.  
  
<h2>Способы уменьшения времени загрузки веб-страницы?</h2>  

  - Минификация и конкатенация JS/CSS файлов.  
  - Оптимизация/сжатие изображений.  
  - Использование CDN. Content Delivery Network  
  - Использование кэширования.  
  
<h2>Особенности разработки мультиязычных сайтов?</h2>    

- Использование lang в HTML. 
- Редирект пользователя на нужный язык.
- Направление чтение текста.
- Форматирование даты и валюты.
- Использование ограничений для текста.
- Порядок слов в предложении.  
  
![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/cd71bf9c-aaa9-491d-b579-bc951f0d283b)  
  
<h2>Что такое Flash Of Unstyled Content? Как его избежать?</h2>  
  
**Flash Of Unstyled Content** (Вспышка не стилизованного контента) - появление неоформленного контента при загрузке.  
Как избежать - **вставить критичный CSS в <head> страницы**.  
  
  <h2>Разница между layout, painting и compositing?</h2>  
  
Все 3 этапа относятся к отрисовке веб-страницы.  
- **layout** - это расчет места для объекта на основе CSS правил.
- **painting** - это рисование пикселей для отображения визуальных элементов.
- **compositing** - это отрисовка слоев в определенном порядке, то есть правильное наложение и т.д.
<a name="pwa"></a>    
<h2>Что такое Progressive Web Application?</h2>  

Progressive Web Application (**PWA**) - это веб сайты, которые ведут себя подобно нативным веб приложениям, они могут быть установлены на телефон или компьютер, а также как правило работают в оффлайн.    

Для последнего используются Service Worker’ы и интерфейс кэширования    
  
Преимущества: **размер и относительная легкость разработки**.  
Нужно    
HTTPS  
Manifest file - позволяет устанавливать pwa на устройство  
Service worker - технология позволяюшая запускать ДЖС в браузере в фоновом режиме. Это проксирующий слой между фронтэндом и бэкэндом, находящийся в браузере. Все запросы браузера идут через него.   
app shell  

Стоит отметить, что спецификация упоминает три типа веб-воркеров:  
  
Выделенные воркеры (Dedicated Workers)  
Разделяемые воркеры (Shared Workers)   
Сервис-воркеры (Service Workers)  

 [вебвокеры](https://habr.com/ru/companies/ruvds/articles/348424/)  
  
<h2>Что такое межсайтовый скриптинг (XSS)?</h2>  

Межсайтовый скриптинг (XSS) - это довольно распространенная уязвимость, которую можно обнаружить на множестве веб приложений  
Суть - злоумышленнику удается внедрить на страницу JS код, который не был предусмотрен разработчиками, и этот код будет выполняться каждый раз, когда пользователи будут заходить на страницу веб приложения куда этот код был добавлен.  
  
<h2>Что такое API?</h2>  

**API** (Application Programming Interface) - набор методов с помощью которых интерфейс может взаимодействовать с базой данных. Описание способов взаимодействия между программами. Как они могут общаться и передавать данные друг другу.  
Это взаимодействие осуществляется с помощью стека CRUD операций.  
Для каждой из этих операций существует свой запрос, который идет на определенный в API url адрес и как-то манипулирует с данными.  

<h2>Что такое CDN?</h2>  

**CDN** (Content Delivery Network) - это группа серверов расположенных во многих местах, эти серверы хранят дублированные копии данных, чтобы ресурсы могли выполнять запросы за ними, в зависимости от того, какие серверы находятся ближе всего к соответствующим конечным пользователям.
В результате, если сайт использует CDN ресурсы, то при обращении к нему, эти ресурсы будут возвращены пользователю от максимально ближайшего сервера.  

<h2>Что такое REST?</h2>   

REST (Representational State Transfer) - это архитектурный стиль API.   
Он не ограничивается никакими протоколами и не имеет собственных методов. Но обычно в RESTful-сервисах используют стандарт HTTP, а файлы передают в формате JSON или XML.  
Каждая единица информации однозначно определяется глобальным идентификатором, таким как URL. Каждая URL в свою очередь имеет строго заданный формат.  
```

```  
**REST API** (Representational State Transfer API) - это архитектурный стиль, который используется для проектирования распределенных систем в сети, таких как веб-сервисы. REST API определяет набор правил и ограничений для взаимодействия между клиентом и сервером.  

Основные принципы REST API:  
  
1. **Клиент-серверная архитектура**: Система состоит из клиента, который отправляет запросы, и сервера, который отвечает на эти запросы. Клиент и сервер могут взаимодействовать независимо друг от друга.
2. **Без состояния**: Клиент и сервер не хранят информацию о предыдущих запросах. Каждый запрос рассматривается независимо от других.
3. **Кэширование**: Ответы от сервера могут быть кэшированы для повторного использования клиентами.
4. **Единообразие интерфейса**: Методы для доступа к ресурсам должны быть однозначно идентифицируемыми и поддерживаться всеми клиентами.
5. **Слои**: Он может иметь промежуточные серверы, которые обрабатывают запросы, например, для балансировки нагрузки или безопасности.

REST API основывается на использовании стандартных HTTP-методов, таких как GET, POST, PUT и DELETE, для доступа к и изменения ресурсов. Клиент отправляет запросы на сервер, указывая метод, URL ресурса и необходимые параметры. Сервер обрабатывает запрос и возвращает соответствующий ответ, который может быть в формате JSON, XML или других.

Пример запроса REST API для получения информации о пользователе: GET /api/users/1  
  
Пример ответа сервера:
{
  "id": 1,
  "name": "John Smith",
  "email": "john@example.com"
} 

  ```

```


<h2>Что такое IP адрес?</h2>  

**IP-адрес** – это уникальный адрес, идентифицирующий устройство в интернете или локальной сети. IP означает «Интернет-протокол» – набор правил, регулирующих формат данных, отправляемых через интернет или локальную сеть.  
  
По сути, IP-адрес – это идентификатор, позволяющий передавать информацию между устройствами в сети: он содержит информацию о местоположении устройства и обеспечивает его доступность для связи.  
  
IP-адрес – это строка чисел, разделенных точками. IP-адреса представляют собой набор из четырех чисел, например, 192.158.1.38. Каждое число в этом наборе принадлежит интервалу от 0 до 255.
  
<h2>Разница между host и domain?</h2>  

**Host** - это сервер, который содержит сайт, у него есть уникальный IP адрес в среде сервисов TCP/IP.  
**Domain** - это адрес сайта, который не похож не на одно другое доменное имя.  

<h2>Разница между URI и URL?</h2>  

**URI** (Uniform Resource Identifier) - имя и адрес ресурса в сети, включает в себя URL и URN.  
Примеры URI: https://www.example.com/my-page, mailto:myemail@example.com, tel:+123456789  
  
**URL** (Uniform Resource Location) - адрес ресурса в сети, определяет местонахождение и способ обращения к нему.  

URN (Uniform Resource Name) - имя ресурса в сети, определяет только название ресурса, но не говорит как к нему подключиться.
Почему очищать кэш важно? Как это сделать?
Почему - если веб сайт был изменен или обновлен, а кэш пользователя все еще ссылается на старые файлы, это может оставить оставить их со старой функциональностью, либо сломать веб сайт.
Как это сделать - присвоить новым файлам другое имя, отличное от прошлого.
Что такое блокирующие и неблокирующие ресурсы?
Блокирующие ресурсы - это ресурсы, которые необходимы для отображения страницы и которые не могут быть загружены асинхронно. Примерами блокирующих ресурсов являются файлы CSS, JavaScript и шрифты.

Неблокирующие ресурсы - это ресурсы, которые могут быть загружены асинхронно, без блокирования парсера. Примерами неблокирующих ресурсов являются изображения и видео.

<h2>Что такое DOM?</h2>  

**DOM** (Document Object Model) - это абстрактное представление HTML-документа с помощью которого браузер может получать доступ к его элементам, изменять его структуру и оформление.
  
<h2>Назовите критические этапы рендеринга?</h2>  

**Critical Rendering Path** - это последовательность шагов, которые выполняет браузер, когда HTML, CSS и JS преобразуются в пиксели, которые видны на экране.
  
**Парсинг HTML и создание DOM**  
**DOM** - ответы в виде HTML превращаются в токены, которые в свою очередь превращаются в узлы и в последующем формируют DOM дерево.   
**CSSOM** - все данные о том как стилизовать DOM.  
**JavaScript** - загрузка всех скриптов.  
**Accessibility Tree** - при парсинге HTML, анализируются специальные атрибуты по типу role и aria.  
**Render Tree** - Соединение DOM и CSSOM.  
**Layout/Reflow** - это процесс определения размеров и позиций всех элементов на странице, а также их отношений друг к другу. Это происходит на основе CSS-правил и содержимого страницы.  
**Paint/Repaint** - это процесс рендеринга элементов на странице. Он включает в себя применение цветов, текстур, градиентов и других стилей к элементам.  
**Compositing** -  это процесс объединения всех элементов на странице в одно изображение. Каждый элемент имеет свою прозрачность и слои, которые могут быть объединены в одно изображение для отображения на экране. Это происходит с помощью графического процессора.    

![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/d3237073-28a7-4580-8778-4f189e2d601d)  


<h2>Когда происходит Reflow и Repaint?</h2>  

Reflow происходит, когда происходят изменения в размерах, позициях или содержимом элементов на странице. Это может произойти при добавлении или удалении элементов, изменении размеров окна браузера или изменении содержимого элементов.

Repaint происходит, когда изменяются стили элементов на странице, но не их размеры или позиции. Это может произойти при изменении цвета фона, шрифта или других стилей элементов.

Разница между preload, prefetch, preconnect и prerender?
preload - говорит браузеру как можно скорее загрузить и кэшировать ресурс.
prefetch - просит браузер загрузить и кэшировать ресурс (например, скрипт или таблицу стилей) в фоновом режиме. Загрузка происходит с низким приоритетом, поэтому не мешает более важным ресурсам.
preconnect - просит браузер заранее подключиться к домену, когда вы хотите ускорить установку соединения в будущем.
prerender - просит браузер загрузить URL-адрес и отобразить его на невидимой вкладке. Когда пользователь нажимает на ссылку, страница должна отобразиться немедленно.
Что такое Core Web Vitals?
Core Web Vitals - это набор метрик, которые используются Google для оценки качества пользовательского опыта на веб-сайтах. Эти метрики включают в себя:

Largest Contentful Paint (LCP) - время загрузки самого большого контентного элемента на странице, такого как изображение или текст.
First Input Delay (FID) - время задержки между первым взаимодействием пользователя с сайтом и реакцией на это действие.
Cumulative Layout Shift (CLS) - мера стабильности макета сайта и отсутствия неожиданных перемещений элементов при загрузке страницы.

Google рекомендует, чтобы все три метрики Core Web Vitals были удовлетворены на сайте, чтобы улучшить пользовательский опыт и рейтинг в поисковой выдаче.
Что такое GraphQL?
GraphQL - это язык запросов для API, который позволяет клиентским приложениям запрашивать только те данные, которые им нужны, и получать их в удобном формате. 

GraphQL работает следующим образом: 

Определение схемы: разработчик определяет схему, которая описывает типы данных и операции, которые могут быть выполнены.
Создание запроса: клиентское приложение создает запрос, указывая необходимые данные и операции.
Обработка запроса: сервер GraphQL обрабатывает запрос и возвращает только запрошенные данные.
Обновление данных: если данные на сервере изменились, клиент может подписаться на определенные данные и получать уведомления об изменениях.

В GraphQL используется одна ссылка(эндпоинт) для всех запросов. Всегда идет POST запрос, даже если мы просто хотим получить какие-то данные. 

GraphQL позволяет улучшить производительность и эффективность API, уменьшив количество запросов и объем передаваемых данных.

mutations
query
overfetching
underfetching

