<h3>
  <img src="../assets/WWW.png" width="16" height="16" />
  <span>Web Technologies:</span>
</h3>

- [Что такое прогрессивный рендеринг?](#prorender)  
- [Что такое прогрессивный SSR?](#ssr)
- [Что такое Progressive Web Application (PWA)?](#pwa)
- [Что такое кроссбраузерность?](#crossbr)
- [Что такое OSI модель?](#osi)
- [Что такое поток документа?](#potok)
- [Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?](#adaptresp)
- [Разница между Progressive Enhancement и Graceful Degradation?](#pevsgd)
- [Что такое Веб-компоненты и какие технологии в них используются?](#webcomp)
- [Особенности разработки мультиязычных сайтов?](#multilang)
- [Что такое REST?](#rest)
- [Что такое REST и RESTful api?](#restfulapi)
- [Принципы REST-архитектуры?](#restful)
- [Что такое модель зрелости Ричардсона?](https://youtu.be/-mWa7erZu64?t=30)
- [Основные уровни модели зрелости Ричардсона?](https://youtu.be/-mWa7erZu64?t=73)
- [Назовите критические этапы рендеринга?](#crt)
- [Разница между layout, painting и compositing?](https://youtu.be/yvOXvZ8aEFo?t=209)
- [Что такое Flash Of Unstyled Content (FOUC)? Как его избежать?](https://youtu.be/yvOXvZ8aEFo?t=164)
- [Что такое History API в браузере?](#historyApi)
- [Что такое веб-хранилище (web storage)?](#webstorage)
- [Разница между `cookie`, `sessionStorage` и `localStorage`?](#storagesdiff)
- [Способы уменьшения времени загрузки веб-страницы?](https://youtu.be/nvktMVFM0_M?t=678)
- [Что такое Core Web Vitals? Какие основные метрики туда входят?](#webvit)
- [Расскажите о метриках Core Web Vitals?](https://youtu.be/DQ0BLu6rZYc?t=314)
- [Разница между `preload`, `prefetch`, `preconnect` и `prerender`?](#prediff)
- [Для чего нужен паттерн PRPL?](#prpl)
- [Что такое Babel](#babel)
 ```

``` 
<h3> Ответы </h3>  
<a name="prorender"></a>    
<h2>Что такое прогрессивный рендеринг?</h2>  

  Прогрессивный рендеринг - это **обобщенное название технологий, которые используются для ускорения отрисовки веб страниц.** 
  Основная идея - это как можно раньше показать пользователю визуальный контент.  
  Цель - уменьшить время загрузки веб-страницы.  

Примеры технологий:  
    - приоритизация видимого контента - preload 
    - отложенные скрипты,  defer
    - асинхронные фрагменты  HTML. async  
    
(PageSpeed Insights)

**технологии прогрессивного рендеринга**  
   
1. **Ленивая загрузка (lazy load) изображений**: позволяет загружать изображения только тогда, когда они попадают в область видимости пользователя на странице. Это можно реализовать с помощью JavaScript, обнаруживая события прокрутки страницы или изменения размера окна и загружая, при необходимости, изображения через AJAX-запросы . Вы также можете использовать атрибуты HTML, такие как "data-src" для сохранения URL-адресов изображений, и динамически заменять значения атрибутов для загрузки изображений при определенных условиях.  

2. **Приоритизация видимого контента**: предполагает загрузку в первую очередь самого важного контента на странице, такого как текст, стили и основные HTML-элементы. Затем, после загрузки основного контента, можно начать загружать остальные элементы страницы. Для этого можно использовать техники асинхронной загрузки ресурсов: использование атрибута `async` для скриптов или асинхронной загрузки стилей. Это можно реализовать, добавляя дополнительные атрибуты и заголовки к вашему HTML/CSS, которые указывают на порядок загрузки ресурсов или использовать инструменты оптимизации, которые автоматически анализируют вашу страницу и оптимизируют порядок загрузки.
   `<script src="script.js" async></script>`,   `<link rel="preload" href="styles.css" as="style">`  

4. **Отложенные скрипты**:  позволяют загружать и запускать скрипты после полной загрузки и отображения основного контента на странице. Это может быть полезно для скриптов, которые не влияют на первоочередные операции и требуют больше времени для выполнения. Для отложенной загрузки и выполнения скриптов вы можете использовать атрибут `defer` для скриптов, чтобы указать браузеру, что он может продолжать загружать остальную часть страницы и выполнять другой код, пока не будет достигнут порядок отложенных скриптов.  

5. **Асинхронные фрагменты HTML**: позволяют загружать отдельные куски HTML-кода асинхронно. Это может быть полезно, если у вас есть отдельные компоненты или виджеты, которые можно загрузить и встроить в основной контент страницы в разное время. Вы можете использовать JavaScript и библиотеки шаблонизации, чтобы загрузить и вставить эти фрагменты HTML в страницу при необходимости.  

```

```
<a name="ssr"></a>
<h2>Прогрессивный рендеринг на стороне сервера</h2>  

SSR (**Server-Side Rendering**)  
Прогрессивный рендеринг на стороне сервера основан на концепции потоковой передачи HTML, он разбивает страницы на осмысленные самостоятельные компоненты с помощью разделения кода. Эти части страницы управляются разными скриптами, в результате чего появляется возможность сделать гидратацию независимо.  
  
  _"гидратация" означает процесс добавления или активации интерактивных элементов на веб-странице после их начальной загрузки. Когда говорят о "гидратации независимо", имеют в виду, что теперь есть возможность активировать/инициализировать каждый компонент страницы независимо от остальных, то есть без необходимости ждать полной загрузки всех компонентов. Это помогает ускорить отображение интерактивности на веб-странице и повысить общую производительность._  
  
**Основные этапы**: 
1. Браузер запрашивает у сервера HTML-код. Сервер получает запрос и начинает выполнение.
2. **Сервер делает API запросы и сначала рендерит критический контент**, а затем отправляет его клиенту. (Сервер анализирует запрошенную страницу и выделяет ее содержимое на разные уровни приоритетности. Некоторые части контента могут быть оценены как критически важные и должны быть возвращены клиенту как можно быстрее.)
3. Браузер анализирует HTML и отображает его на экране.
4. **Сервер рендерит некритический контент** и передает его браузеру.
5. Затем браузер анализирует и отображает некритичный контент.
6. **Между тем JS-бандлы загружаются и выполняются в фоновом режиме, а браузер передаёт интерактивность элементам DOM**.
  
Прогрессивный рендеринг +  
  + повышает производительность веб-приложения извлекая и визуализируя компоненты страницы параллельно.
  + уменьшает нагрузку на клиентское устройство
  + улучшает SEO, так как поисковые роботы видят полный контент страницы

Фреймворки, которые реализуют server rendering - Next.js  
Реализуется с помощью getServerSideProps, которые потом передаются в пропс компоненту.  
  
```

```

<h2>Разница между SSR и SSG и CSR?</h2> 

[почитать статью](https://inverser.pro/220-csr-ssr-ssg-kakaya-raznitsa-v-renderinge-stranitsy)   
[и эту статью](https://the-evening-code.com/posts/server-side-rendering-vs-static-site-generators)  
  
  CSR - **Client** Side Rendering. рендеринг приложения в браузере с помощью DOM.  
  SSR - **Server** Side Rendering. рендеринг клиентской части приложения на сервере.  
  SSG - **Static Site Generator**. генерация всех HTML страниц приложения в момент сборки.    
  
**CSR** (Client Side Rendering)- на стороне клиента -  используются со всеми популярными фреймворками.  
  **Ресурсы загружаются единожды, весь бандл, html css. Весь рендер происходит в браузере.**  
  _Минусы_ - долгое первичное время загрузки, изначально пустой html, слабое SEO.  
  _Плюсы+_ - весь процесс работы с API на стороне клиента. Может быть закешировано. Экономия ресурсов сервера.  

  **Преимущество CSR над SSR** в том, что данный тип рендеринга позволяет значительно сократить трафик и нагрузку на сервер, поставляя клиенту JS-бандл (JavaScript-файл), в котором уже содержится какой-то из frameworks, после чего дальнейшее взаимодействие пользователя и сервера, а также переходы по страницам, идут в асинхронном режиме, без перезагрузки всего содержимого DOM, как при классическом SSR.

   
**SSR** (Server-Side Rendering) означает, что HTML страницы на каждый запрос генерируются на сервере и отправляются на клиентский браузер уже готовыми. Это позволяет улучшить SEO, так как поисковые роботы видят полный контент страницы, а также ускорить первоначальную загрузку страницы. Фреймворки, которые реализуют server rendering - Next.js

Реализуется с помощью [getServerSideProps](https://nextjs.org/docs/pages/api-reference/functions/get-server-side-props), которые потом передаются в пропс компоненту.  
```javascript
import { getServerSideProps } from 'next'
import axios from 'axios'
//////////////////////////////
export const getServerSideProps = async (context) => {
  // Получаем данные из строки запроса
  const { id } = context.query

  // Получаем данные с внешнего API
  const res = await axios.get(`https://api.example.com/data/${id}`)
  const data = res.data

  // Передаем данные на страницу через объект props
  return { props: { data } }
}
//////////////////////////////
export default function Page({ data }) {
  // Рендерим данные на странице
  return <div>{data.title}</div>
}
```
  
Плюсы: Отрисовка быстрая  

**SSG** (Static Site Generation) означает, что HTML страницы генерируются на стадии сборки проекта и сохраняются в виде статических файлов. Это позволяет ускорить загрузку страницы, так как сервер не нужно генерировать страницу каждый раз при запросе, а также уменьшить нагрузку на сервер.  
Основное отличие между SSR и SSG заключается в том, что:  
  - SSR генерирует страницы динамически на каждый запрос, всё происходит на сервере.  
  - а SSG генерирует страницы статически на этапе сборки проекта. все происходит на клиенте.    
Т.е. Вы один раз на своём ПК сгенерировали страницы, загрузили их на сервер и он отдаёт просто статику. Т.е. не нужен НИ PHP, ни NodeJS, можно ставить nginx и всё.

**-** вместо использования HTML и CSS, теперь мы используем современные инструменты, такие как React, Vue и Angular. То есть приложение, написанное на современных инструментах преобразуется в HTML, CSS и JavaScript с помощью транспиляторов, сборщиков пакетов и т.д.  


<img src="https://github.com/AntonGitCode/FEFAQ/assets/117078390/0520ea4b-c956-49d0-bdc7-25d5272958c6" alt="Image Description" width="550">  
**SPA** - Single Page Application. Одностраничное приложение - это веб-приложение или веб-сайт, использующий единственный HTML-документ как оболочку для всех веб-страниц и организующий взаимодействие с пользователем через динамически подгружаемые HTML, CSS, JavaScript, обычно посредством AJAX  
  
<img src="https://github.com/AntonGitCode/FEFAQ/assets/117078390/adf3ccea-6d59-45d5-a770-94a1c5f88dfa" alt="Image Description" width="100%">  

```

```
<a name="potok"></a>
<h2>Что такое поток документа?</h2> 

**Поток** - это **принцип организации элементов на странице, при отсутствии стилей**.  
  
Даже если мы не стилизуем страницу при помощи CSS, то отображение элементов в браузере будет предсказуемо, так как у тегов есть стили по умолчанию, зашитые в движок браузера. Благодаря ним заголовок **h1** больше заголовка **h2**, а ссылки синие и подчеркнутые.  
  
Все элементы на странице можно разделить на 2 категории:   
**блочные**(div) и **строчные**(span).  
    
**float** и **position** (absolute, fixed, sticky) - вырывают элемент из нормального потока документа.   
```

```
пример кода:
  
создаем шаблон  
```html
<template id="myComponent">
  <style>
    /* стили компонента */
  </style>
  <div>
    <!-- содержимое компонента -->
  </div>
</template>
```  
  
склонировать шаблон и добавить его в Shadow DOM элемента:  
  
```javascript
const template = document.querySelector('#myComponent');
const clone = template.content.cloneNode(true);
element.attachShadow({ mode: 'open' }).appendChild(clone);
```

  
<a name="adaptresp"></a>
<h2>Разница между адаптивным(adaptive) и отзывчивым(responsive) дизайнами?</h2>  

  основное отличие между этими приёмами:  
  — отзывчивый дизайн — один макет для всех устройств  
  — адаптивный дизайн — один макет для каждого вида устройства  

**Адаптивный дизайн** - это по сути несколько версий одного и того же сайта, которые загружаются в зависимости от того на каком устройстве открыт сайт. В адаптивном дизайне есть несколько версий html js css файлов одной и той же страницы.  

**Отзывчивый дизайн** - это более широкий подход, при котором веб-страница реагирует на действия пользователя и обновляется динамически без перезагрузки страницы. Это может включать в себя мгновенное изменение размеров, цветов, добавление или удаление элементов веб-страницы и т.д. Отзывчивый дизайн (Responsive Web Design) объединяет в себе три методики  
  — гибкий макет на основе сетки  
  — гибкие изображения и медиазапросы  
  — Размеры задаются относительные - в %.   
```

```
<a name="pevsgd"></a>  
<h2>Разница между Progressive Enhancement и Graceful Degradation?</h2>  

Эти оба подхода используются для создания кроссплатформенных и кроссбраузерных приложений.  
**Progressive Enhancement** - предполагает поэтапное создание веб интерфейсов от простого к сложному, на каждом из этапов создается законченный веб интерфейс как улучшенная версия предыдущего (от mobile до desktop).  
**Graceful Degradation** - функционал сайта деградирует от сложного к более простому. Сначала создается максимально функциональная версия веб страницы в современном браузере, а затем идет деградация до более ранних версий.  
```

```
<a name="osi"></a> 
<h2> Что такое OSI-модель - Open Systems Interconnection</h2>  

  
протокол HTTP функционирует на прикладном уровне OSI (7 уровень)  
протокол TCP и UDP - на транспортном уровне OSI (4 уровень)  
протокол IP - на сетевом уровне OSI (3 уровень)  
протокол Ethernet и MAC адресация - на канальном уровне OSI (2 уровень)  
провода, оптика, радиоволны, т.е. среда передачи сигнала - на физическом уровне OSI (1 уровень)  
  
<img src="https://github.com/AntonGitCode/FEFAQ/assets/117078390/3b9051ae-c74e-4aff-8979-fb766b8260c8" alt="Image Description" width="550">  

![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/1db5424f-8699-433b-84f2-da4a9e962cd2)  
  
![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/73d0e38e-a301-4905-b077-58d1293e719b)
  
<a name="crossbr"></a>  
<h2>Что такое кроссбраузерность?</h2>  

**Кроссбраузерность** - это корректная адаптивная верстка для правильного отображения сайта или приложения в разных браузерах и на разных устройствах. 
Подходы для создания кроссбраузерного сайта: 
- семантическая верстка,
-  использование reset или normalize css,
-  добавление вендорных префиксов,
-  использование полифилов и транспайлиров по типу Babel.
    
```

```
<a name="vendor"></a>
<h2>Вендорные префиксы</h2>  

Часто разработчики топовых браузеров внедряют новые свойства css, которые еще не стандартизированы. Эти свойства предваряются специальными приставками, которые называются «вендорные префиксы». Каждый браузер имеет свой префикс:  
  
-o- — префикс для браузера Опера  
-moz- — префикс для браузера Mozilla  
-ms — префикс для Internet Explorer  
-webkit- — префикс для браузеров, построенных на движке Webkit, таких, как Safari и Chrome  
 ```

```
<a name="babel"></a>
<h2>Что такое Babel и для чего он используется?</h2>  

Babel - это транспайлер, который **переписывает код с современного стандарта JavaScript на более ранний**  
  
  **программа позволяющая менять исходный код одной программы на эквивалентный код на другом языке.** 
  
Основная идея: Ecma International каждый год выпускает обновления для JS, однако эти обновления внедряются в браузер постепенно, чтобы не терять время и сразу начать использовать новые фичи, которые зачастую упрощают разработку используется Babel, которые транслирует язык на более ранний для лучшей кроссбраузерности.  
```

```
<h2>Разница между feature detection, feature inference и анализом строки user-agent?</h2>  

**Feature detection** (определение возможностей браузера) - заключается в определении поддерживает ли браузер определенный блок кода, и если блок не поддерживается, то будет выполнен аналог, либо полифил, такой подход помогает обеспечить работоспособность, и предотвратить сбои и ошибки.  
  
  ![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/4c5dc9ed-8a68-49e5-b892-1ec9b5396935)  
   
  или  
```javascript
// Feature detection - проверяем поддерживает ли браузер метод addEventListener
if (window.addEventListener) {
  // Если поддерживает, то добавляем обработчик события
  window.addEventListener('load', function() {
    console.log('Страница загружена!');
  });
} else {
  // Если не поддерживает, используем альтернативный способ
  window.onload = function() {
    console.log('Страница загружена!');
  };
}
```

  
**Feature inference** (определение возможностей) - это проверка на наличие определенных возможностей, подход применяет функцию, которая предполагает, что определенная возможность уже существует. Если фича Х работает, то и фича У должна работать.  

  ![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/cc1bd96a-f119-40b3-a475-90868e80abd4)  
    

  
**User-agent** - строка сообщаемая браузером, которая позволяет определить: тип приложения, операционную систему, поставщика ПО. Доступ к ней можно получить через **navigator.userAgent**.
Рекомендуется использовать первый вариант, так как ненадежность (user-agent строки могут быть поддельными или измененными) и сложность поддержки (браузеры могут изменять формат user-agent строки).  

```
  
```  
<a name="webcomp"></a>  
<h2>Что такое Веб-компоненты и какие технологии в них используются?</h2>  

**Веб-компоненты** - это технология, которая позволяет создавать многократно используемые компоненты в веб документах и приложениях, они **поддерживаются браузерами напрямую** и не требуют библиотек для работы.  
это набор веб-технологий, которые **позволяют создавать переиспользуемые компоненты пользовательского интерфейса** для веб-приложений.  

**_html templates_**  
Встроенный элемент <template> предназначен для хранения шаблона HTML. Браузер полностью игнорирует его содержимое, проверяя лишь синтаксис, но мы можем использовать этот элемент в JavaScript, чтобы создать другие элементы. Внутри тега `<template>` вы можете разместить HTML-код.   
  
**_html import_**   
  
**_custom elements_**  
```
class MyElement extends HTMLElement {  
  constructor() {  
    super();
    // элемент создан
  }
 connectedCallback() {
    // браузер вызывает этот метод при добавлении элемента в документ
    // (может вызываться много раз, если элемент многократно добавляется/удаляется)
  }
}

// Регистрируем пользовательский HTML-элемент
customElements.define('my-component', MyElement);
```

После регистрации пользовательского элемента `my-component` с помощью метода `customElements.define`, мы можем использовать его в HTML-разметке:
  
```html
<body>
  <my-component></my-component>
</body>
```  
**!** Имя пользовательского элемента должно содержать дефис -, например, my-element и super-button  
  
**_shadow dom_**  
Теневой DOM – это способ создать свой, изолированный, DOM для компонента.  
shadowRoot = elem.attachShadow({mode: open|closed}) – создаёт теневой DOM для elem. Если mode="open", он доступен через свойство elem.shadowRoot.  
Мы можем создать подэлементы внутри shadowRoot с помощью innerHTML или других методов DOM.  
  
<h2>Способы уменьшения времени загрузки веб-страницы?</h2>  

  - Минификация и конкатенация JS/CSS файлов.  
  - Оптимизация/сжатие изображений.  
  - Использование CDN. Content Delivery Network  
  - Использование кэширования.  

<a name="multilang"></a>
<h2>Особенности разработки мультиязычных сайтов?</h2>    

- Использование lang в HTML. 
- Редирект пользователя на нужный язык.
- Направление чтение текста.
- Форматирование даты и валюты.
- Использование ограничений для текста.
- Порядок слов в предложении.  
  
![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/cd71bf9c-aaa9-491d-b579-bc951f0d283b)  
  
<h2>Что такое Flash Of Unstyled Content? Как его избежать?</h2>  
  
**Flash Of Unstyled Content** (Вспышка не стилизованного контента) - появление неоформленного контента при загрузке.  
Как избежать - **вставить критичный CSS в <head> страницы**.  
  
  <h2>Разница между layout, painting и compositing?</h2>  
  
Все 3 этапа относятся к отрисовке веб-страницы.  
- **layout** - это расчет места для объекта на основе CSS правил. определение блочной модели (margin, padding, border) и определение положения элементов в потоке документа.
- **painting** - это рисование пикселей для отображения визуальных элементов.
- **compositing** - это отрисовка слоев в определенном порядке, то есть правильное наложение и т.д.
  
<a name="pwa"></a>    
<h2>Что такое Progressive Web Application?</h2>  

Progressive Web Application (**PWA**) - это веб сайты, которые ведут себя подобно нативным веб приложениям, они могут быть установлены на телефон или компьютер, а также как правило работают в оффлайн.    

Для последнего используются Service Worker’ы и интерфейс кэширования    
  
Преимущества: **размер и относительная легкость разработки**.  
Нужно    
HTTPS  
Manifest file - позволяет устанавливать pwa на устройство  
Service worker - технология позволяюшая запускать ДЖС в браузере в фоновом режиме. Это проксирующий слой между фронтэндом и бэкэндом, находящийся в браузере. Все запросы браузера идут через него.   
app shell  

Стоит отметить, что спецификация упоминает три типа веб-воркеров:  
  
Выделенные воркеры (Dedicated Workers)  
Разделяемые воркеры (Shared Workers)   
Сервис-воркеры (Service Workers)  

 [вебвокеры](https://habr.com/ru/companies/ruvds/articles/348424/)  
  
<h2>Что такое межсайтовый скриптинг (XSS)?</h2>  

Межсайтовый скриптинг (XSS) - это довольно распространенная уязвимость, которую можно обнаружить на множестве веб приложений  
Суть - злоумышленнику удается внедрить на страницу JS код, который не был предусмотрен разработчиками, и этот код будет выполняться каждый раз, когда пользователи будут заходить на страницу веб приложения куда этот код был добавлен.  
  
<h2>Что такое API?</h2>  

**API** (Application Programming Interface) - набор методов с помощью которых интерфейс может взаимодействовать с базой данных. Описание способов взаимодействия между программами. Как они могут общаться и передавать данные друг другу.  
Это взаимодействие осуществляется с помощью стека CRUD операций.  
Для каждой из этих операций существует свой запрос, который идет на определенный в API url адрес и как-то манипулирует с данными.  

<h2>Что такое CDN?</h2>  

**CDN** (Content Delivery Network) - это группа серверов расположенных во многих местах, эти серверы хранят дублированные копии данных, чтобы ресурсы могли выполнять запросы за ними, в зависимости от того, какие серверы находятся ближе всего к соответствующим конечным пользователям.
В результате, если сайт использует CDN ресурсы, то при обращении к нему, эти ресурсы будут возвращены пользователю от максимально ближайшего сервера.  


<h2>Что такое IP адрес?</h2>  

**IP-адрес** – это уникальный адрес, идентифицирующий устройство в интернете или локальной сети. IP означает «Интернет-протокол» – набор правил, регулирующих формат данных, отправляемых через интернет или локальную сеть.  
  
По сути, IP-адрес – это идентификатор, позволяющий передавать информацию между устройствами в сети: он содержит информацию о местоположении устройства и обеспечивает его доступность для связи.  
  
IP-адрес – это строка чисел, разделенных точками. IP-адреса представляют собой набор из четырех чисел, например, 192.158.1.38. Каждое число в этом наборе принадлежит интервалу от 0 до 255.
  
<h2>Разница между host и domain?</h2>  

**Host** - это сервер, который содержит сайт, у него есть уникальный IP адрес в среде сервисов TCP/IP.  
**Domain** - это адрес сайта, который не похож не на одно другое доменное имя.  

<h2>Разница между URI и URL?</h2>  

**URI** (Uniform Resource Identifier) - имя и адрес ресурса в сети, включает в себя URL и URN.  
Примеры URI: https://www.example.com/my-page, mailto:myemail@example.com, tel:+123456789  
  
**URL** (Uniform Resource Location) - адрес ресурса в сети, определяет местонахождение и способ обращения к нему.  

URN (Uniform Resource Name) - имя ресурса в сети, определяет только название ресурса, но не говорит как к нему подключиться.
Почему очищать кэш важно? Как это сделать?
Почему - если веб сайт был изменен или обновлен, а кэш пользователя все еще ссылается на старые файлы, это может оставить оставить их со старой функциональностью, либо сломать веб сайт.
Как это сделать - присвоить новым файлам другое имя, отличное от прошлого.
Что такое блокирующие и неблокирующие ресурсы?
Блокирующие ресурсы - это ресурсы, которые необходимы для отображения страницы и которые не могут быть загружены асинхронно. Примерами блокирующих ресурсов являются файлы CSS, JavaScript и шрифты.

Неблокирующие ресурсы - это ресурсы, которые могут быть загружены асинхронно, без блокирования парсера. Примерами неблокирующих ресурсов являются изображения и видео.

<h2>Что такое DOM?</h2>  

**DOM** (Document Object Model) - это абстрактное представление HTML-документа с помощью которого браузер может получать доступ к его элементам, изменять его структуру и оформление.

<a name="crt"></a>
<h2>Назовите критические этапы рендеринга?</h2>  

**Critical Rendering Path** - это последовательность шагов, которые выполняет браузер, когда HTML, CSS и JS преобразуются в пиксели, которые видны на экране.
  
**Парсинг HTML и создание DOM**  
**DOM** - ответы в виде HTML превращаются в токены, которые в свою очередь превращаются в узлы и в последующем формируют DOM дерево.   
**CSSOM** - все данные о том как стилизовать DOM.  
**JavaScript** - загрузка всех скриптов.  
**Accessibility Tree** - при парсинге HTML, анализируются специальные атрибуты по типу role и aria.  
**Render Tree** - Соединение DOM и CSSOM.  
**Layout/Reflow** - это процесс определения размеров и позиций всех элементов на странице, а также их отношений друг к другу. Это происходит на основе CSS-правил и содержимого страницы.  
**Paint/Repaint** - это процесс рендеринга элементов на странице. Он включает в себя применение цветов, текстур, градиентов и других стилей к элементам.  
**Compositing** -  это процесс объединения всех элементов на странице в одно изображение. Каждый элемент имеет свою прозрачность и слои, которые могут быть объединены в одно изображение для отображения на экране. Это происходит с помощью графического процессора.    

![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/d3237073-28a7-4580-8778-4f189e2d601d)  


<h2>Когда происходит Reflow и Repaint?</h2>  

**Reflow** происходит, **когда происходят изменения в размерах, позициях или содержимом элементов** на странице. Это может произойти при добавлении или удалении элементов, изменении размеров окна браузера или изменении содержимого элементов.

**Repaint** происходит, **когда изменяются стили элементов на странице**, но не их размеры или позиции. Это может произойти при изменении цвета фона, шрифта или других стилей элементов.

<a name="prediff"></a>
<h2>Разница между preload, prefetch, preconnect и prerender?</h2>  

**preload** - говорит браузеру как можно скорее загрузить и кэшировать ресурс.  
**prefetch** - просит браузер загрузить и кэшировать ресурс (например, скрипт или таблицу стилей) в фоновом режиме. Загрузка происходит с низким приоритетом, поэтому не мешает более важным ресурсам.  
**preconnect** - просит браузер заранее подключиться к домену, когда вы хотите ускорить установку соединения в будущем.  
**prerender** - просит браузер загрузить URL-адрес и отобразить его на невидимой вкладке. Когда пользователь нажимает на ссылку, страница должна отобразиться немедленно.  prerender полезен для страниц, которые пользователи обычно посещают, таких как главная страница или страницы с популярным контентом

<a name="webvit"></a>
<h2> Что такое Core Web Vitals? </h2>  

Core Web Vitals - это **набор метрик, которые используются Google для оценки качества пользовательского опыта на веб-сайтах.** Эти метрики включают в себя:

— **Largest Contentful Paint** (LCP) - время загрузки самого большого контентного элемента на странице, такого как изображение или текст.  
— **First Input Delay** (FID) - время задержки между первым взаимодействием пользователя с сайтом и реакцией на это действие.  
— **Cumulative Layout Shift** (CLS) - мера стабильности макета сайта и отсутствия неожиданных перемещений элементов при загрузке страницы.  
  
Google рекомендует, чтобы все три метрики Core Web Vitals были удовлетворены на сайте, чтобы улучшить пользовательский опыт и рейтинг в поисковой выдаче.  

<a name="historyApi"></a>
<h2>Что такое History API в браузере?</h2>  

DOM-объект Window предоставляет доступ к истории текущей сессии браузера через объект **history**.  
  
window.history.back();  
window.history.forward();  
// Обе следующих инструкции обновляют текущую страницу  
window.history.go(0)  
window.history.go()  
window.history.pushState(data, title [, url])  

Добавляет новый элемент в историю. Метод принимает три параметра:  
data - Данные состояния истории. Эти данные можно получить затем в обработчике события popstate. Если дополнительные данные не требуются можно передавать null;  
title - Заголовок страницы, который отобразится в окне браузер, так же можно передавать null;  
url - URL, который должен отображаться в адресной строке.  

``` 
window.location
```
  
![image](https://github.com/AntonGitCode/FEFAQ/assets/117078390/afc4fe0e-8850-4305-915a-40c109dab4d1)

**history.pushstate** does not make a new HTTP call. it might attempt to load the URL later, for instance after the user restarts the browser.
**window.location.href** = "url" navigates the browser to new location, so it does make a new http request. Note: exception is the case when you specify new url as hash fragment. Then window is just scrolled to corresponding anchor  

  
<a name="webstorage"></a>
<h2>Что такое веб-хранилище (web storage)?</h2>  

Web Storage API -  это механизм, который позволяет веб-приложениям хранить данные на клиентской стороне, то есть на компьютере пользователя. Он предоставляет два объекта для хранения данных: localStorage и sessionStorage.

<a name="storagesdiff"></a>
<h2>Разница между cookie, sessionStorage и localStorage?</h2>  
  
1. **Cookie**:  является механизмом хранения данных на стороне клиента в виде текстовых файлов. Они могут использоваться для хранения небольших объемов данных (обычно до 4 КБ). обычно для сохранения состояния сеанса, пользовательских предпочтений, данных аутентификации и другой информации. Кроме того, cookie имеют срок годности (expiration), который задается при создании, и они могут иметь ограниченную область видимости (привязанную к определенному доменау и пути).  
  
2. **sessionStorage**:  предоставляет механизм для хранения данных на стороне клиента на время одной сессии браузера. Данные, сохраненные в sessionStorage, остаются доступными только в текущей вкладке или окне браузера, и они удаляются, когда пользователь закрывает вкладку или окно. sessionStorage обычно используется для временного хранения данных, таких как состояние формы, открытые вкладки или временные настройки.  
  
3. **localStorage**:  также предоставляет механизм для хранения данных на стороне клиента, но с более длительным временем жизни. Данные, сохраненные в localStorage, остаются доступными даже после закрытия браузера и перезагрузки компьютера. Они не имеют временных ограничений и остаются сохраненными до тех пор, пока не будут явно удалены или очищены пользователем. localStorage обычно используется для хранения постоянных данных, таких как настройки пользователя или локальное хранилище данных для веб-приложений.

   Итак, основные различия между cookie, sessionStorage и localStorage заключаются в их
   - временном существовании
   - области видимости
   - целях использования.
  
<a name="prpl"></a>
<h2>Для чего нужен паттерн PRPL?</h2>

Паттерн PRPL (**Push**, **Render**, **Pre-cache**, **Lazy-load**) - **это стратегия оптимизации загрузки веб-приложений**, особенно в контексте разработки Progressive Web Applications (PWA). Этот паттерн позволяет улучшить производительность загрузки страницы и сократить время отклика для пользователей.

PRPL предполагает следующие шаги:
  
1. Push (предварительная загрузка): Загрузка наиболее критических ресурсов (например, HTML, CSS, JavaScript) в фоновом режиме, чтобы сократить время загрузки страницы.  
  
2. Render (рендеринг): Пользователю показывается минимальный набор контента, необходимый для начала отображения страницы. Это позволяет ускорить первоначальное отклика и создать ощущение быстрой загрузки страницы.  
  
3. Pre-cache (предзагрузка): Загрузка остальных ресурсов, которые понадобятся в дальнейшем, в фоновом режиме. Это позволяет кэшировать ресурсы для более быстрой загрузки при последующих запросах.  
  
4. Lazy-load (ленивая загрузка): Загрузка остальных ресурсов необходимых для отображения страницы по мере их фактического использования. Это позволяет снизить инициальную загрузку страницы и оптимизировать использование сетевых ресурсов.
  
Использование паттерна PRPL помогает создать более быстрые и отзывчивые веб-приложения, уменьшить размер загрузки страницы и улучшить опыт пользователя. 

<a name="rest"></a>
<h2>Что такое REST?</h2>   
  
REST (Representational State Transfer) — стиль общения компонентов, при котором все необходимые данные указываются в параметрах запроса.  
  
REST сейчас — один из самых распространённых стилей API в интернете.  
  
Отличительная особенность этого стиля — это стиль построения адресов и выбор метода. Всё взаимодействие между клиентом и сервером сводится к 4 операциям (CRUD):  
  
созданию чего-либо, например, объекта пользователя (create, C);  
чтению (read, R);  
обновлению (update, U);  
удалению (delete, D).  
  
Для каждой из операций есть собственный HTTP-метод:  
  
**POST** для создания;  
**GET** для чтения;  
**PUT**, **PATCH** для обновления;  
**DELETE** для удаления.  
Разница между PUT и PATCH в том, что PUT обновляет объект целиком, а PATCH — только указанное поле.

Адрес, как правило, остаётся почти одинаковым, а детали запроса указываются в HTTP-методе и параметрах или теле запроса.

REST (Representational State Transfer) - это архитектурный стиль API.   
Он не ограничивается никакими протоколами и не имеет собственных методов. Но обычно в RESTful-сервисах используют стандарт HTTP, а файлы передают в формате JSON или XML.  
Каждая единица информации однозначно определяется глобальным идентификатором, таким как URL. Каждая URL в свою очередь имеет строго заданный формат.  
  
<a name="restfulapi"></a>
  
<h2> RESTful API</h2>  
  
**REST API** (Representational State Transfer API) - это архитектурный стиль, который используется для проектирования распределенных систем в сети, таких как веб-сервисы. REST API определяет набор правил и ограничений для взаимодействия между клиентом и сервером.  
  
<a name="restful"></a>
<h2>Принципы RESTful-архитектуры</h2>  
  Основные принципы REST API:  
  
1. **Клиент-серверная архитектура**: Система состоит из клиента, который отправляет запросы, и сервера, который отвечает на эти запросы. Клиент и сервер могут взаимодействовать независимо друг от друга.
2. **Без состояния**: Клиент и сервер не хранят информацию о предыдущих запросах. Каждый запрос рассматривается независимо от других.
3. **Кэширование**: Ответы от сервера могут быть кэшированы для повторного использования клиентами.
4. **Единообразие интерфейса**: Методы для доступа к ресурсам должны быть однозначно идентифицируемыми и поддерживаться всеми клиентами.
5. **Слои**: Он может иметь промежуточные серверы, которые обрабатывают запросы, например, для балансировки нагрузки или безопасности.

REST API основывается на использовании стандартных HTTP-методов, таких как GET, POST, PUT и DELETE, для доступа к и изменения ресурсов. Клиент отправляет запросы на сервер, указывая метод, URL ресурса и необходимые параметры. Сервер обрабатывает запрос и возвращает соответствующий ответ, который может быть в формате JSON, XML или других.

Пример запроса REST API для получения информации о пользователе: GET /api/users/1  
  
Пример ответа сервера:
{
  "id": 1,
  "name": "John Smith",
  "email": "john@example.com"
} 

<h2>Что такое GraphQL?</h2>  
  
**GraphQL** - это язык запросов для API, который позволяет клиентским приложениям запрашивать только те данные, которые им нужны, и получать их в удобном формате.  
  
GraphQL работает следующим образом:  
  
Определение схемы: разработчик определяет схему, которая описывает типы данных и операции, которые могут быть выполнены.
Создание запроса: клиентское приложение создает запрос, указывая необходимые данные и операции.
Обработка запроса: сервер GraphQL обрабатывает запрос и возвращает только запрошенные данные.
Обновление данных: если данные на сервере изменились, клиент может подписаться на определенные данные и получать уведомления об изменениях.

В GraphQL используется одна ссылка(эндпоинт) для всех запросов. Всегда идет POST запрос, даже если мы просто хотим получить какие-то данные. 

GraphQL позволяет улучшить производительность и эффективность API, уменьшив количество запросов и объем передаваемых данных.

mutations
query
overfetching
underfetching

<h2>Что такое модель зрелости Ричардсона? Основные уровни модели зрелости Ричардсона?</h2>
  
  Модель зрелости Ричардсона (или модель способностей Ричардсона) представляет собой модель, разработанную Ричардом Ричардсоном, которая классифицирует организации по их способностям в области управления программными продуктами. Эта модель помогает оценить текущее состояние организации и определить потенциал для улучшения ее процессов и практик.  
  
Модель зрелости Ричардсона включает пять уровней, описывающих различные стадии зрелости организаций:  

1. Начинающий (Level 1 - Initial): Организация находится на начальном уровне зрелости, когда ее процессы разработки программного обеспечения нерегулярны и не стандартизированы. Работа выполняется на индивидуальном уровне без установленных процедур и методологий.  

2. Управляемый (Level 2 - Managed): На этом уровне организация начинает внедрять базовые практики управления процессами разработки ПО. Она придерживается установленных процедур и стандартов, имеет основную структуру управления проектами.  

3. Определенный (Level 3 - Defined): На этом уровне организация имеет установленные и формализованные процессы разработки и управления ПО. Она следит за качеством и эффективностью своих проектов и использует опыт и уроки, извлеченные из предыдущих проектов.  

4. Процессно управляемый (Level 4 - Quantitatively Managed): На этом уровне организация измеряет и анализирует процессы разработки ПО. Она использует числовые данные для определения уровня качества и производительности своих проектов, чтобы принимать осознанные улучшения.  

5. Оптимизирующий (Level 5 - Optimizing): Этот уровень представляет собой высшее достижение зрелости. Организация на данном уровне постоянно стремится к улучшению своих процессов и практик на основе накопленного опыта. Она предпринимает инновационные шаги и поощряет новаторство в области управления программными продуктами.  
  
Модель зрелости Ричардсона позволяет организациям оценить свои способности в управлении программными продуктами и разработать стратегию для улучшения  
